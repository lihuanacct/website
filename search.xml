<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker、gitlab-runner</title>
    <url>/Docker%E3%80%81gitlab-runner/</url>
    <content><![CDATA[<p>下面是在master虚拟机进行<br>安装jdk<br>安装maven</p>
<p>在docker 中创建卷<br>在 Docker 中，卷是一种用于持久化数据的机制。它允许容器内的数据在容器被删除后仍然保留，并且可以被其他容器共享使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker volume create gitlab-etc</span><br><span class="line">docker volume create gitlab-log</span><br><span class="line">docker volume create gitlab-opt</span><br></pre></td></tr></table></figure>

<p>gitlab-etc：可能用于存储 GitLab 容器的配置文件。GitLab 是一个基于Web的Git代码仓库管理工具，配置文件通常包含了GitLab的设置、参数、密钥等信息。</p>
<p>gitlab-log：可能用于存储 GitLab 容器的日志文件。在这个卷中，GitLab 容器将把日志文件写入到这个位置，你可以随时查看这些日志以了解 GitLab 容器的运行情况。</p>
<p>gitlab-opt：可能用于存储 GitLab 容器的其他数据。这可能包括一些持久化的存储数据、插件、脚本等。</p>
<p>启动gitlab容器，并通过挂载卷、端口映射等方式实现持久化存储和网络配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name gitlab \    </span><br><span class="line">--hostname 192.168.223.129 \    </span><br><span class="line">--restart=always \          </span><br><span class="line">-p 80:80 \                     </span><br><span class="line">-p 443:443 \				     			</span><br><span class="line">-v gitlab-etc:/etc/gitlab \</span><br><span class="line">-v gitlab-log:/var/log/gitlab \</span><br><span class="line">-v gitlab-opt:/var/opt/gitlab \</span><br><span class="line">-d gitlab/gitlab-ce:17.0.0-ce.0	</span><br><span class="line">												</span><br><span class="line">指定容器名称。</span><br><span class="line">设置容器主机名。</span><br><span class="line">设置容器遇到异常退出时总是重新启动。相当于开机时自启。</span><br><span class="line">将主机的 80 端口映射到容器的 80 端口，以及将主机的 443 端口映射到容器的 443 端口。这是为了让GitLab 的 Web 服务（HTTP 和 HTTPS）可以从外部访问。 前面为主机端口，后面为容器端口。</span><br><span class="line">将之前创建的三个卷 gitlab-etc、gitlab-log 和 gitlab-opt 分别挂载到容器的 /etc/gitlab、/var/log/gitlab 和 /var/opt/gitlab 目录，实现了持久化存储。</span><br><span class="line">以后台守护进程的方式运行容器。指定要运行的 Docker 镜像，这里是 GitLab CE 的版本号为 17.0.0-ce.0 的镜像。</span><br></pre></td></tr></table></figure>

<p>查看gitlab日志文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f gitlab</span><br></pre></td></tr></table></figure>

<p>查找GitLab 容器初始化时生成的管理员密码。用户名为root</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it gitlab grep &#x27;Password:&#x27; /etc/gitlab/initial_root_password</span><br></pre></td></tr></table></figure>

<p>登录官网，修改密码</p>
<p>下面是在node虚拟机</p>
<p>安装jdk<br>安装maven<br>上面的版本个master相同</p>
<p>添加安装源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner//script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure>

<p>安装gitlab-runner</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install -y gitlab-runner-17.0.0</span><br></pre></td></tr></table></figure>

<p>#查看所有用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -d: -f1 /etc/passwd</span><br></pre></td></tr></table></figure>


<p>#删除gitlab-runner配置信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo gitlab-runner uninstall</span><br></pre></td></tr></table></figure>

<p>这一步是为了下面配置某些用户执行某些命令的权限，而不是所有人都可以执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-runner install --working-directory /home/gitlab-runner --user root</span><br></pre></td></tr></table></figure>

<p>设置gitlab下载的代码放在&#x2F;home&#x2F;gitlab-runner 目录下，同时让这条命令由root用户执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload  重新加载守护进程的配置文件</span><br><span class="line">systemctl start gitlab-runner  开启gitlab-runner</span><br><span class="line">systemctl enable gitlab-runner  将gitlab-runner 设置为开机自启</span><br></pre></td></tr></table></figure>



<p>创建一个runner</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240523193157972.png" alt="image-20240523193157972"></p>
<p>添加标签,相当于给这个runner起了个名字。</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240523193127185.png" alt="image-20240523193127185"></p>
<p>将这段代码复制到node虚拟机执行。将gitlab-runner注册到master</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240523193501370.png" alt="image-20240523193501370"></p>
<p>执行器选择 shell</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240523193644637.png" alt="image-20240523193644637"></p>
<p>创建代码仓库</p>
<p>上传代码</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240523193948828.png" alt="image-20240523193948828"></p>
<p>安装好maven 后，在node节点中的maven配置文件  settings.xml 中将镜像仓库改为阿里云</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;mirror&gt;  </span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;  </span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;  </span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;  </span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;  </span><br><span class="line">&lt;/mirror&gt; </span><br></pre></td></tr></table></figure>

<p>在 .gitlab-ci.yml文件中添加镜像源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- mvn -s/opt/environment/apache-maven-3.8.8/conf/settings.xml clean package</span><br></pre></td></tr></table></figure>

<p>在idea 项目根目录中中创建Dockerfile 和 .gitlab-ci.yml文件</p>
<p>Dockerfile用于镜像打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-slim</span><br><span class="line">ADD ./target/my-project.jar /usr/local/</span><br><span class="line">CMD [&quot;java&quot;,&quot;-jar&quot;,&quot;/usr/local/my-project.jar&quot;]</span><br><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure>

<p>.gitlab-ci.yml</p>
<p>用于说明gitlab-ci执行的流程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - build-image</span><br><span class="line">  - push-image</span><br><span class="line">build:</span><br><span class="line">  stage: build</span><br><span class="line">  rules:</span><br><span class="line">    - if: &#x27;$CI_COMMIT_TAG&#x27;   //设置为，当建立新的TAG 时，开始构建</span><br><span class="line">      allow_failure: false</span><br><span class="line">    - when: never</span><br><span class="line">  tags:</span><br><span class="line">    - shared</span><br><span class="line">  script:</span><br><span class="line">    - mvn -s/opt/environment/apache-maven-3.8.8/conf/settings.xml clean package</span><br><span class="line">  artifacts:</span><br><span class="line">    paths:</span><br><span class="line">      - target/*.jar</span><br><span class="line">build-image:</span><br><span class="line">  stage: build-image</span><br><span class="line">  tags:</span><br><span class="line">  	#指定哪个 runner执行</span><br><span class="line">    - shared    </span><br><span class="line">  rules:</span><br><span class="line">    - if: &#x27;$CI_COMMIT_TAG&#x27;</span><br><span class="line">      allow_failure: false</span><br><span class="line">    - when: never</span><br><span class="line">  script:</span><br><span class="line">    - docker build -t registry.cn-hangzhou.aliyuncs.com/k8s-images01/my-project:$CI_COMMIT_TAG .</span><br><span class="line">push-image:</span><br><span class="line">  stage: push-image</span><br><span class="line">  tags:</span><br><span class="line">    - shared</span><br><span class="line">  rules:</span><br><span class="line">    - if: &#x27;$CI_COMMIT_TAG&#x27;</span><br><span class="line">      allow_failure: false</span><br><span class="line">    - when: never</span><br><span class="line">  script:</span><br><span class="line">    - docker login --username=aliyun1875389260 --password=lihuan123 registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">    - docker push registry.cn-hangzhou.aliyuncs.com/k8s-images01/my-project:$CI_COMMIT_TAG</span><br></pre></td></tr></table></figure>

<p>pom文件需要修改</p>
<p>需要加上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;finalName&gt;my-project&lt;/finalName&gt;</span><br></pre></td></tr></table></figure>

<p>避免打包后的文件名和 Dockerfile中不一致。</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240523222746191.png" alt="image-20240523222746191"></p>
<p>每创建一次tag，CI 就执行一次</p>
<p>流程走完</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240523222938234.png" alt="image-20240523222938234"></p>
<p>Gitlab-runner 流水线参数</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>job</code></td>
<td>每个作业运行不同的命令。可以定义一个或多个作业(job)。 每个作业必须具有唯一的名称（不能使用关键字）。 每个作业是独立执行的。 每个作业至少要包含一个script。</td>
</tr>
<tr>
<td><code>script</code></td>
<td>运行的Shell命令或脚本</td>
</tr>
<tr>
<td><code>image</code></td>
<td>使用Docker映像</td>
</tr>
<tr>
<td><code>services</code></td>
<td>使用Docker服务映像</td>
</tr>
<tr>
<td><code>before_script</code></td>
<td>在作业运行前运行脚本</td>
</tr>
<tr>
<td><code>after_script</code></td>
<td>在作业运行后运行脚本</td>
</tr>
<tr>
<td><code>stages</code></td>
<td>定义管道中的阶段，运行顺序</td>
</tr>
<tr>
<td><code>stage</code></td>
<td>为工作定义一个阶段（可选，未指定默认为test阶段）</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>用于从允许运行该项目的所有Runner列表中选择特定的Runner,<code>tags</code>可让指定了标签的runner来运行作业</td>
</tr>
<tr>
<td><code>only</code></td>
<td>定义哪些分支和标签的git项目将会被job执行。</td>
</tr>
<tr>
<td><code>except</code></td>
<td>定义哪些分支和标签的git项目将不会被job执行。</td>
</tr>
<tr>
<td><code>rules</code></td>
<td>条件列表，用于评估和确定作业的选定属性，以及是否创建该作业</td>
</tr>
<tr>
<td><code>allow_failure</code></td>
<td>允许作业失败（失败的工作不会影响提交状态）,默认为 false</td>
</tr>
<tr>
<td><code>when</code></td>
<td>什么时候开始工作</td>
</tr>
<tr>
<td><code>environment</code></td>
<td>作业部署到的环境的名称</td>
</tr>
<tr>
<td><code>cache</code></td>
<td>在后续运行之间应缓存的文件列表</td>
</tr>
<tr>
<td><code>artifacts</code></td>
<td>成功时附加到作业的文件和目录列表</td>
</tr>
<tr>
<td><code>dependencies</code></td>
<td>通过提供要从中获取工件的作业列表，限制将哪些工件传递给特定作业</td>
</tr>
<tr>
<td><code>coverage</code></td>
<td>给定作业的代码覆盖率设置</td>
</tr>
<tr>
<td><code>retry</code></td>
<td>发生故障时可以自动重试作业的时间和次数</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>定义自定义作业级别的超时（优先于项目范围的设置）</td>
</tr>
<tr>
<td><code>parallel</code></td>
<td>多少个作业实例应并行运行</td>
</tr>
<tr>
<td><code>trigger</code></td>
<td>定义下游管道触发器</td>
</tr>
<tr>
<td><code>include</code></td>
<td>允许此作业包括外部YAML文件</td>
</tr>
<tr>
<td><code>extends</code></td>
<td>该作业将要继承的配置条目</td>
</tr>
<tr>
<td><code>pages</code></td>
<td>上载作业结果以用于GitLab页面</td>
</tr>
<tr>
<td><code>variables</code></td>
<td>在作业级别上定义作业变量</td>
</tr>
<tr>
<td><code>interruptible</code></td>
<td>定义在通过新的运行使其冗余时是否可以取消作业</td>
</tr>
<tr>
<td><code>resource_group</code></td>
<td>限制作业并发</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM</title>
    <url>/JVM/</url>
    <content><![CDATA[<h1 id="1-内存结构"><a href="#1-内存结构" class="headerlink" title="1 内存结构"></a>1 内存结构</h1><h2 id="1、简述一下JVM的内存结构？-高频"><a href="#1、简述一下JVM的内存结构？-高频" class="headerlink" title="1、简述一下JVM的内存结构？(高频)"></a>1、简述一下JVM的内存结构？(高频)</h2><p>JVM在执行Java程序时，会把它管理的内存划分为若干个的区域，每个区域都有自己的用途和创建销毁时间。如下图所示，可以分为两大部分，线程私有区和共享区。</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840648.png" alt="img"></p>
<h3 id="线程私有区"><a href="#线程私有区" class="headerlink" title="线程私有区"></a>线程私有区</h3><h4 id="①-程序计数器"><a href="#①-程序计数器" class="headerlink" title="① 程序计数器"></a>① 程序计数器</h4><ul>
<li><p>作用：是一块较小的内存空间[寄存器]，可以理解为是当前线程所执行程序的字节码文件的行号指示器，存储的是当前线程所执行的<strong>行号</strong></p>
</li>
<li><p>特点：①线程私有 ，②唯一一个不会出现内存溢出的内存空间</p>
</li>
</ul>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840949.png" alt="img"></p>
<h4 id="②-虚拟机栈"><a href="#②-虚拟机栈" class="headerlink" title="② 虚拟机栈"></a>② 虚拟机栈</h4><p>栈的结构，先进后出</p>
<p>虚拟机栈:每个线程运行时所需要的内存</p>
<p>作用：管理JAVA方法执行的内存模型。每个方法执行时都会创建一个栈桢[每个方法运行时需要的内存]用来存储方法中局部变量表、操作数栈、动态链接、方法的返回地址。栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss参数可以设置虚拟机栈大小）</p>
<p>虚拟机栈包括：</p>
<h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><p>方法中定义的局部变量以及方法的参数都会放在这张表中，单纯的存储单元</p>
<h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈:"></a>操作数栈:</h6><p>以压栈以及出栈的方式存储操作数</p>
<h6 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接:"></a>动态链接:</h6><p>符合方法引用转换为具体的方法引用</p>
<h6 id="方法的返回地址"><a href="#方法的返回地址" class="headerlink" title="方法的返回地址:"></a>方法的返回地址:</h6><p>方法正常退出时，调用者的PC寄存器的值作为返回地址，即调用该方法的指令的下一条指令的地址</p>
<p>特点：<br>1、线程私有<br>2、局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）以及对象引用（reference 类型）<br>3、栈太小或者方法调用过深，都将抛出StackOverflowError异常 </p>
<p> 测试代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackDemo02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录调用了多少次出现了栈内存溢出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            show() ;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;show方法被调用了:&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        count++ ;</span><br><span class="line">        System.out.println(<span class="string">&quot;show方法执行了.....&quot;</span>);</span><br><span class="line">        show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>配置虚拟机参数-Xss可以指定栈内存大小；例如：-Xss180k</p>
<p>栈内存的默认值问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">The <span class="keyword">default</span> value depends on the platform: </span><br><span class="line">* Linux/x64 (<span class="number">64</span>-bit): <span class="number">1024</span> KB </span><br><span class="line">* macOS (<span class="number">64</span>-bit): <span class="number">1024</span> KB </span><br><span class="line">* Oracle Solaris/x64 (<span class="number">64</span>-bit): <span class="number">1024</span> KB </span><br><span class="line">* Windows: The <span class="keyword">default</span> value depends on virtual memory</span><br></pre></td></tr></table></figure>



<p>思考：</p>
<p>虚拟机栈的大小是不是设置的越大越好?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不是， 假如把栈一个设置成1G , 我的电脑只要16G  ,最多只能有16个线程运行</span><br></pre></td></tr></table></figure>



<h4 id="③-本地方法-native-栈"><a href="#③-本地方法-native-栈" class="headerlink" title="③ 本地方法[native]栈"></a>③ 本地方法[native]栈</h4><p>与虚拟机栈作用相似。但它不是为Java方法服务的，而是本地方法（C语言）。由于规范对这块没有强制要求，不同虚拟机实现方法不同。</p>
<h3 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h3><p>① 堆内存、② 方法区</p>
<h4 id="①-堆内存"><a href="#①-堆内存" class="headerlink" title="① 堆内存"></a>① 堆内存</h4><ul>
<li>作用：是Java内存区域中一块用来存放对象实例的区域，新创建的对象，数组都使用堆内存；【从Java7开始，常量池也会使用堆内存】</li>
</ul>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840682.png" alt="img"></p>
<p>Java 堆从GC的角度还可以细分为: 新生代( Eden[伊甸园区) 、From 和 To [Survivor幸存区] )和老年代。</p>
<ul>
<li><p>特点：<br>  1、被线程共享，因此需要考虑线程安全问题<br>  2、会产生内存溢出问题 	</p>
</li>
<li><p>测试代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个ArrayList对象</span></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">arrayList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                arrayList.add(<span class="keyword">new</span> <span class="title class_">Object</span>()) ;</span><br><span class="line">                count++ ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable a) &#123;</span><br><span class="line">            a.printStackTrace();</span><br><span class="line">            <span class="comment">// 输出程序执行的次数</span></span><br><span class="line">            System.out.println(<span class="string">&quot;总共执行了:&quot;</span> + count + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>虚拟机参数：</li>
</ul>
<p>​	-Xms	设置最小堆内存大小(不能小于1024K); 	-Xms 堆内存初始大小，可以通过jmap工具进行查看</p>
<p>​	-Xmx	设置最大堆内存大小(不能小于1024K);   -Xmx 堆内存最大值，可以通过jmap工具进行查看</p>
<p>​	例如：-Xms1024K -Xmx2048K</p>
<p>注意：</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840798.png" alt="img"></p>
<p>常见的堆内存诊断工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. jps工具</span><br><span class="line">	查看当前系统中有哪些java进程</span><br><span class="line">2. jmap工具</span><br><span class="line">	查看某一时刻堆内存的占用情况</span><br><span class="line">3. jconsole工具</span><br><span class="line">	图形界面，功能强大可连续检测</span><br></pre></td></tr></table></figure>



<h4 id="②-方法区"><a href="#②-方法区" class="headerlink" title="② 方法区"></a>② 方法区</h4><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840816.png" alt="img" style="zoom:67%;">



<ul>
<li><p>作用：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 </p>
</li>
<li><p>特点：<br>  1、方法区是一块线程共享的内存区域<br>  2、方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出的错误<br>  3、jdk1.6和jdk1.7方法区也常常被称之为永久区(永久代),大小一般都是几百兆；<br>  4、jdk1.8已经将方法区取消，替代的是元数据区(元空间),如果不指定大小，默认情况下，虚拟机会耗尽可用系统内存<br>  5、jdk7以后就将方法区中的常量池移动至<strong>堆内存</strong></p>
</li>
</ul>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840671.png" alt="img"></p>
<p>为什么将方法区中的常量池移动至<strong>堆内存</strong> ，变化的原因：</p>
<p>​		1、提高内存的回收效率(方法区内存的回收效率远远低于堆内存，因为方法去中存储的都是类信息，静态变量…这些信息不能被轻易回收)</p>
<p>​		2、字符串常量池在方法区，那么很容易产生内存溢出(因为方法区的垃圾回收效率比较低);</p>
<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	jdk1.8的元数据区可以使用参数-XX:MaxMetaspaceSzie设定大小	</span></span><br><span class="line"><span class="comment"> * 演示元空间内存溢出</span></span><br><span class="line"><span class="comment"> * -XX:-UseCompressedClassPointers -XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> 	UseCompressedClassPointers使用指针压缩，如果不使用这个参数可能会出现: Compressed class space内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxMetaspaceDemo</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;				<span class="comment">// 当前这个类就是一个类加载器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义变量，记录程序产生类的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">MaxMetaspaceDemo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MaxMetaspaceDemo</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 字节码写入器：生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 定义一个类版本为Opcodes.V1_1，它的访问域为public，名称为Class&#123;i&#125;,父类为java.lang.Object，不实现任何接口</span></span><br><span class="line">                cw.visit(Opcodes.V1_1, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 加载该类</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、堆和栈的区别？-高频"><a href="#2、堆和栈的区别？-高频" class="headerlink" title="2、堆和栈的区别？(高频)"></a>2、堆和栈的区别？(高频)</h2><p>① 功能不同：栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。</p>
<p>② 共享性不同：栈内存是线程私有的。堆内存是所有线程共有的。</p>
<p>③ 异常错误不同：如果栈内存或者堆内存不足都会抛出异常。栈空间不足：java.lang.StackOverFlowError。堆空间不足：java.lang.OutOfMemoryError。</p>
<p>④ 空间大小：栈的空间大小远远小于堆的。</p>
<h2 id="3、怎么获取Java程序使用的内存？堆使用的百分比？"><a href="#3、怎么获取Java程序使用的内存？堆使用的百分比？" class="headerlink" title="3、怎么获取Java程序使用的内存？堆使用的百分比？"></a>3、怎么获取Java程序使用的内存？堆使用的百分比？</h2><p>可以通过java.lang.Runtime类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。</p>
<p>1、Runtime.freeMemory() 方法返回剩余空间的字节数</p>
<p>2、Runtime.totalMemory()方法总内存的字节数</p>
<h2 id="4、栈帧都有哪些数据？"><a href="#4、栈帧都有哪些数据？" class="headerlink" title="4、栈帧都有哪些数据？"></a>4、栈帧都有哪些数据？</h2><p>栈帧包含：局部变量表、操作数栈、动态链接、方法的返回地址等。</p>
<h2 id="5、如何启动系统的时候设置jvm的启动参数？"><a href="#5、如何启动系统的时候设置jvm的启动参数？" class="headerlink" title="5、如何启动系统的时候设置jvm的启动参数？"></a>5、如何启动系统的时候设置jvm的启动参数？</h2><p>其实都很简单，比如说采用”java -jar”的方式启动一个jar包里面的系统，那么就可以才用类似下面的格式：</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840607.png" alt="img"></p>
<ul>
<li><p>-Xms:最小堆内存大小</p>
</li>
<li><p>-Xmx:最大堆内存大小</p>
</li>
<li><p>-Xmn:设置年轻代大小</p>
</li>
<li><p>-Xss:设置虚拟机栈大小</p>
</li>
<li><p>-XX:MaxPermSize:非堆区分配的内存的最大上限</p>
</li>
<li><p>-XX:PermSize:非堆区初始内存分配大小</p>
</li>
</ul>
<h1 id="2-垃圾回收"><a href="#2-垃圾回收" class="headerlink" title="2 垃圾回收"></a>2 垃圾回收</h1><h2 id="6、如何判断一个对象是否为垃圾？-高频"><a href="#6、如何判断一个对象是否为垃圾？-高频" class="headerlink" title="6、如何判断一个对象是否为垃圾？(高频)"></a>6、如何判断一个对象是否为垃圾？(高频)</h2><p>两种算法：</p>
<p>① 引用计数法、② 可达性分析算法</p>
<p><strong>① 引用计数法</strong>：堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a &#x3D; b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。</p>
<p>特点：简单、无法解决循环引用问题</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840784.png" alt="img"></p>
<p>定义学生类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义成员变量</span></span><br><span class="line">    <span class="keyword">public</span> Object instance ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	jvm参数：-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps</span></span><br><span class="line"><span class="comment">	-verbose:gc -XX:+PrintGCDetails：打印gc日志信息</span></span><br><span class="line"><span class="comment">	-XX:+PrintGCTimeStamps: 打印gc日志的时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountGcDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建Student对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>() ;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>() ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进行循环引用</span></span><br><span class="line">        a.instance = b ;</span><br><span class="line">        b.instance = a ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将a对象和b对象设置为null</span></span><br><span class="line">        a = <span class="literal">null</span> ;</span><br><span class="line">        b = <span class="literal">null</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用System.gc进行垃圾回收</span></span><br><span class="line">        System.gc();                    <span class="comment">// 如果没有触发垃圾回收说明Hotspot的jvm使用的就是引用计数法来判断对象是否为垃圾</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>控制台输出gc日志:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0.076</span>: [GC (System.gc()) [PSYoungGen: 7802K-&gt;856K(151552K)] 7802K-&gt;864K(498688K), <span class="number">0.0008493</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="number">0.077</span>: [Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 856K-&gt;0K(151552K)] [ParOldGen: 8K-&gt;620K(347136K)] 864K-&gt;620K(498688K), [Metaspace: 3356K-&gt;3356K(1056768K)], <span class="number">0.0044768</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 151552K, used 3901K [<span class="number">0x0000000716c00000</span>, <span class="number">0x0000000721500000</span>, <span class="number">0x00000007c0000000</span>)</span><br><span class="line">  eden space 130048K, <span class="number">3</span>% used [<span class="number">0x0000000716c00000</span>,<span class="number">0x0000000716fcf748</span>,<span class="number">0x000000071eb00000</span>)</span><br><span class="line">  from space 21504K, <span class="number">0</span>% used [<span class="number">0x000000071eb00000</span>,<span class="number">0x000000071eb00000</span>,<span class="number">0x0000000720000000</span>)</span><br><span class="line">  to   space 21504K, <span class="number">0</span>% used [<span class="number">0x0000000720000000</span>,<span class="number">0x0000000720000000</span>,<span class="number">0x0000000721500000</span>)</span><br><span class="line"> ParOldGen       total 347136K, used 620K [<span class="number">0x00000005c4400000</span>, <span class="number">0x00000005d9700000</span>, <span class="number">0x0000000716c00000</span>)</span><br><span class="line">  object space 347136K, <span class="number">0</span>% used [<span class="number">0x00000005c4400000</span>,<span class="number">0x00000005c449b318</span>,<span class="number">0x00000005d9700000</span>)</span><br><span class="line"> Metaspace       used 3365K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 370K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>日志解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">① <span class="number">0.076</span>: 代表gc发生的时间，从jvm启动以来经过的秒数</span><br><span class="line">② [GC和[Full Gc: 说明这次垃圾收集器的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有<span class="string">&quot;Full&quot;</span>，说明此次GC发生了stop-the-world。System.gc()是说明显示的调用了				   System.gc方法进行垃圾回收</span><br><span class="line">③ [PSYoungGen：表示GC发生的区域, 不同的垃圾收集器展示的区域名称不一样，PSYoungGen表示的是新生代，这里默认使用的是Parallel Scavenge收集器 (-XX:+UseSerialGC)</span><br><span class="line">④ 7802K-&gt;856K(151552K)：GC前该区域已使用容量 -&gt; GC后该区域已使用容量(该区域的总容量)</span><br><span class="line">⑤ 7802K-&gt;864K(498688K)：GC前Java堆已使用容量 -&gt; GC后Java堆已使用容量(Java堆总容量)</span><br><span class="line">⑥ <span class="number">0.0008493</span> secs：该区域GC所占用的时间</span><br><span class="line">⑦ [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>, real=<span class="number">0.00</span> secs]: 分别表示用户态消耗的CPU时间、内核态消耗的CPU时间和操作从开始到结束所经过的墙钟时间(墙钟时间包括非运算的等待耗时)。多线程操作会叠加这些CPU时间，所以user、sys时间超过real时间是完全正常的。</span><br></pre></td></tr></table></figure>



<p><strong>② 可达性分析算法</strong> ： 可达性分析算法又叫做<strong>跟搜索法</strong>，就是通过一系列的称之为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到GC Roots没有任何引用链相连时（即从GC Roots节点到该节点不可达），则证明该对象是不可用的。</p>
<h2 id="7、可达性算法中，哪些对象可作为GC-Roots对象？-高频"><a href="#7、可达性算法中，哪些对象可作为GC-Roots对象？-高频" class="headerlink" title="7、可达性算法中，哪些对象可作为GC Roots对象？(高频)"></a>7、可达性算法中，哪些对象可作为GC Roots对象？(高频)</h2><p>1、虚拟机栈中引用的对象</p>
<p>2、方法区静态成员引用的对象</p>
<p>3、方法区常量引用对象</p>
<p>4、本地方法栈引用的对象</p>
<h2 id="8、Java中都有哪些引用类型？-高频"><a href="#8、Java中都有哪些引用类型？-高频" class="headerlink" title="8、Java中都有哪些引用类型？(高频)"></a>8、Java中都有哪些引用类型？(高频)</h2><p>① 强引用、② 软引用、③ 弱引用、④ 虚引用</p>
<p><strong>① 强引用</strong>：StrongReference</p>
<p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class="line">obj = <span class="literal">null</span>;  <span class="comment">//手动置null</span></span><br></pre></td></tr></table></figure>

<p>只要<strong>强引用存在，垃圾回收器将永远不会回收被引用的对象</strong>，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrongReferenceDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;() ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ;  x &lt; <span class="number">10</span> ; x++) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>];</span><br><span class="line">            list.add(buff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>② 软引用</strong>：SoftReference</p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。</p>
<p>在 JDK1.2 之后，用java.lang.ref.<strong>SoftReference</strong>类来表示软引用。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SoftReferenceDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建数组对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;<span class="type">byte</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>]) ;</span><br><span class="line">            list.add(softReference) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.gc();  <span class="comment">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ((SoftReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现无论循环创建多少个软引用对象，打印结果总是有一些为null，这里就说明了在内存不足的情况下，软引用将会被自动回收。</p>
<p><strong>③ 弱引用</strong></p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2之后,用java.lang.ref.WeakReference来表示弱引用。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数：-verbose:gc -XX:+PrintGCDetails -Xms10M -Xmx10M -Xmn5M</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeakReferenceDemo01</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建数组对象</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x++) &#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;<span class="type">byte</span>[]&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1</span>]) ;</span><br><span class="line">            list.add(weakReference) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.gc();  <span class="comment">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ((WeakReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>④ 虚引用</strong></p>
<p>虚引用是最弱的一种引用关系，如果<strong>一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收</strong>，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReference</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Reference</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns this reference object&#x27;s referent.  Because the referent of a</span></span><br><span class="line"><span class="comment">     * phantom reference is always inaccessible, this method always returns</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new phantom reference that refers to the given object and</span></span><br><span class="line"><span class="comment">     * is registered with the given queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; It is possible to create a phantom reference with a &lt;tt&gt;null&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * queue, but such a reference is completely useless: Its &lt;tt&gt;get&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * method will always return null and, since it does not have a queue, it</span></span><br><span class="line"><span class="comment">     * will never be enqueued.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> referent the object the new phantom reference will refer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> q the queue with which the reference is to be registered,</span></span><br><span class="line"><span class="comment">     *          or &lt;tt&gt;null&lt;/tt&gt; if registration is not required</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PhantomReference</span><span class="params">(T referent, ReferenceQueue&lt;? <span class="built_in">super</span> T&gt; q)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(referent, q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<p>1、每次垃圾回收时都会被回收，主要用于监测对象是否已经从内存中删除。</p>
<p>2、虚引用必须和引用队列关联使用, 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。</p>
<p>3、程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;Object&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个虚引用，指向一个Object对象</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), referenceQueue);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 主动通知垃圾回收器进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从引用队列中获取元素, 该方法是阻塞方法</span></span><br><span class="line">        System.out.println(referenceQueue.remove()); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>小结:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1)强引用(StrongReference)</span><br><span class="line">	只有所有GC Roots对象都不通过强引用引用该对象，该对象才能被垃圾回收</span><br><span class="line">	如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，JVM就可以适时的回收对象了</span><br><span class="line">(2)软引用(SoftReference) [重点]</span><br><span class="line">	软引用是用来描述一些非必需但仍有用的对象，</span><br><span class="line">	在垃圾回收后，内存扔不足就会再次触发垃圾回收，回收软引用对象</span><br><span class="line">	场景:缓存</span><br><span class="line">(3)弱引用(WeakReference)[重点]</span><br><span class="line">	弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</span><br><span class="line">(4)虚引用(PhantomReference) [fæntəm]</span><br><span class="line">	虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收</span><br></pre></td></tr></table></figure>



<h2 id="9、常见的垃圾回收算法都有哪些？-高频"><a href="#9、常见的垃圾回收算法都有哪些？-高频" class="headerlink" title="9、常见的垃圾回收算法都有哪些？(高频)"></a>9、常见的垃圾回收算法都有哪些？(高频)</h2><p>① 标记清除、② 标记整理、③复制算法、④ 分代回收</p>
<p><strong>① 标记清除</strong></p>
<p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840802.png" alt="img"></p>
<p>优点：速度比较快</p>
<p>缺点：会产生内存碎片，碎片过多，仍会使得连续空间少</p>
<p><strong>② 标记整理</strong></p>
<p>执行过程：首先标记出所有需要回收的对象，在标记完成后统一进行整理，整理是指存活对象向一端移动来减少内存碎片，相对效率较低</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840916.png" alt="img"></p>
<p>优点：无内存碎片</p>
<p>缺点：效率较低</p>
<p><strong>③ 复制算法</strong></p>
<p>执行过程：开辟两份大小相等空间，一份空间始终空着，垃圾回收时，将存活对象拷贝进入空闲空间；</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840063.png" alt="img"></p>
<p>优点：无内存碎片</p>
<p>缺点：占用空间多</p>
<p>注意：如果有很多对象的存活率较高，这时我们采用复制算法，那么效率就比较低；</p>
<p><strong>④ 分代回收</strong></p>
<p>概述：根据对象存活周期的不同，将对象划分为几块，比如Java的堆内存，分为新生代和老年代，然后根据各个年代的特点采用最合适的算法；</p>
<p>新生代对象的存活的时间都比较短，因此使用的是【复制算法】；而老年代对象存活的时间比较长那么采用的就是【标记清除】或者【标记整理】；</p>
<h2 id="10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？"><a href="#10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？"></a>10、简述Java垃圾回收机制？有什么办法主动通知虚拟机进行垃圾回收？</h2><p>​		在Java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p>
<h1 id="3-对象分配"><a href="#3-对象分配" class="headerlink" title="3 对象分配"></a>3 对象分配</h1><h2 id="11、对象在内存中是如何进行分配的？-高频"><a href="#11、对象在内存中是如何进行分配的？-高频" class="headerlink" title="11、对象在内存中是如何进行分配的？(高频)"></a>11、对象在内存中是如何进行分配的？(高频)</h2><p>① 对象优先在Eden分配、② 大对象直接晋升至老年代</p>
<p><strong>① 对象优先在Eden分配</strong>：对象优先在『伊甸园』分配，当『伊甸园』没有足够的空间时，触发 ‘Minor GC’(小范围的GC)</p>
<p>情况一：伊甸园的内存空间足够，不会发生’Minor GC’</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840380.png" alt="img"></p>
<p>情况二：伊甸园的空间不够了</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840609.png" alt="img"></p>
<p>垃圾回收线程启动，进行垃圾回收，此时会触发”stop the world”(停止所有用户线程)，</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840661.png" alt="img"></p>
<p>Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄最多到一定值(最大值是15，对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁)(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840699.png" alt="img"></p>
<p>“From”和”To”会交换他们的角色,下一次垃圾回收的时候也是从Eden将存活的对象复制到TO区</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840693.png" alt="img"></p>
<p>Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<p>案例演示：</p>
<p>jvm参数设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>UseSerialGC <span class="operator">-</span>verbose:gc <span class="operator">-</span>XX:<span class="operator">+</span>PrintGCDetails <span class="operator">-</span>XX:<span class="operator">+</span>PrintGCTimeStamps <span class="operator">-</span>Xloggc:.<span class="operator">/</span>gc.log <span class="operator">-</span>Xms20M <span class="operator">-</span>Xmx20M <span class="operator">-</span>Xmn10M <span class="operator">-</span>XX:SurvivorRatio<span class="operator">=</span><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>UseSerialGC 是指使用 Serial <span class="operator">+</span> SerialOld 回收器组合</span><br><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>PrintGCDetails <span class="operator">-</span>verbose:gc 是指打印 GC 详细信息</span><br><span class="line"><span class="operator">-</span>XX:<span class="operator">+</span>PrintGCTimeStamps 打印gc日志的时间戳</span><br><span class="line"><span class="operator">-</span>Xloggc:.<span class="operator">/</span>gc.log 将gc日志输出到一个日志文件中</span><br><span class="line"><span class="operator">-</span>Xms20M <span class="operator">-</span>Xmx20M <span class="operator">-</span>Xmn10M 是指分配给JVM的最小，最大以及新生代内存</span><br><span class="line"><span class="operator">-</span>XX:SurvivorRatio<span class="operator">=</span><span class="number">8</span> 是指『伊甸园』与『幸存区 <span class="keyword">From</span>』和『幸存区 <span class="keyword">To</span>』比例为 <span class="number">8</span>:<span class="number">1</span>:<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>定义内存大小变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512KB</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7MB</span> <span class="operator">=</span> <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8MB</span> <span class="operator">=</span> <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>



<p>案例1：创建一个4M的数组，查看内存分配情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 创建一个4M大小的数组</span><br><span class="line">byte[] bytes = new byte[_4MB];</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 8192K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K, <span class="number">100</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>)  <span class="comment">// 在伊甸园中创建对象</span></span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 0K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,   <span class="number">0</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 376K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>没有触发GC操作，对象直接在Eden分配；</p>
<p>案例2：创建一个7M的数组，查看内存分配情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个7M大小的数组</span></span><br><span class="line"><span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_7MB] ;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-- 触发垃圾回收</span><br><span class="line">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class="number">0.0023439</span> secs] 2004K-&gt;647K(19456K), <span class="number">0.0024142</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 7897K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">88</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff314930</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">63</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff5a1e58</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 0K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,   <span class="number">0</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3446K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 376K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>由于程序在启动的时候jdk内部还会存在一些对象的创建，因此当我们分配了一个7M的内存空间，eden内存不足，因此发生了一次Minor GC！并且将存活下的对象最终存储到from区中。</p>
<p>案例3： 在案例3的基础上，在分配一个512KB的数组内存空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_7MB] ;</span><br><span class="line"><span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2005K-&gt;623K(9216K), <span class="number">0.0015235</span> secs] 2005K-&gt;623K(19456K), <span class="number">0.0015799</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 8713K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">98</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff3e6820</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">60</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff59bdb8</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 0K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,   <span class="number">0</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3444K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 376K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>触发一次GC操作！并且将存活下的对象最终存储到from区中，第二次分配_512KB大小的内存空间的时候，直接在伊甸园分配即可。</p>
<p>案例4： 在4的基础上在分配一个512KB的数组内存空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_7MB] ;</span><br><span class="line"><span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_512KB] ;</span><br><span class="line"><span class="type">byte</span>[] bytes3 = <span class="keyword">new</span> <span class="title class_">byte</span>[_512KB] ;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2004K-&gt;620K(9216K), <span class="number">0.0018706</span> secs] 2004K-&gt;620K(19456K), <span class="number">0.0019275</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8628K-&gt;539K(9216K), <span class="number">0.0063389</span> secs] 8628K-&gt;8323K(19456K), <span class="number">0.0063773</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.01</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 1133K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,   <span class="number">7</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec94930</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,  <span class="number">52</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff486de0</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 7784K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">76</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffd9a040</span>, <span class="number">0x00000000ffd9a200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 376K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>触发了2次垃圾回收！并且将from区中存活的对象存储到老年代！</p>
<p><strong>② 大对象直接晋升至老年代</strong></p>
<p>当对象太大，伊甸园包括幸存区都存放不下时，这时候老年代的连续空间足够，此对象会直接晋升至老年代，不会发生 GC</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840815.png" alt="img"></p>
<p>结果</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840803.png" alt="img"></p>
<p>案例演示：</p>
<p>案例1：直接分配一个8M的内存空间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure>

<p>伊甸园总大小只有 8 MB，但新分配的对象大小已经是 8MB，而幸存区都仅有 1MB，也无法容纳这个对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 2169K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,  <span class="number">26</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fee1e560</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 8192K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">80</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffe00010</span>, <span class="number">0x00000000ffe00200</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3443K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 376K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>可以看到结果并没有发生 GC，大对象直接被放入了老年代「tenured generation  total 10240K, used 8192K」</p>
<p>案例演示2：老年代连续空间不足，触发 Full GC</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="title class_">byte</span>[_8MB] ;</span><br><span class="line"><span class="type">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="title class_">byte</span>[_8MB] ;</span><br></pre></td></tr></table></figure>

<p>第一个 8MB 直接进入老年代，第二个 8MB 对象在分配时发现老年代空间不足，只好尝试先进行一次 Minor GC，结果发现新生代没有连续空间，只好触发一次 Full GC，最后发现老年代也没有连续空间，这时出现 OutOfMemoryError</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 2004K-&gt;647K(9216K), <span class="number">0.0022693</span> secs][Tenured: 8192K-&gt;8838K(10240K), <span class="number">0.0452151</span> secs] 10197K-&gt;8838K(19456K), [Metaspace: 3438K-&gt;3438K(1056768K)], <span class="number">0.0504669</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.05</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Allocation Failure)</span> [TenuredException in thread <span class="string">&quot;main&quot;</span> : 8838K-&gt;8820K(10240K), <span class="number">0.0027463</span> secs] 8838K-&gt;8820K(19456K), [Metaspace: 3438K-&gt;3438K(1056768K)], <span class="number">0.0027877</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.itheima.jvm.gc.ObjectMemoryDemo.main(ObjectMemoryDemo.java:<span class="number">14</span>)</span><br><span class="line">Heap</span><br><span class="line"> def <span class="keyword">new</span> <span class="title class_">generation</span>   total 9216K, used 246K [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  eden space 8192K,   <span class="number">3</span>% used [<span class="number">0x00000000fec00000</span>, <span class="number">0x00000000fec3d890</span>, <span class="number">0x00000000ff400000</span>)</span><br><span class="line">  from space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff500000</span>, <span class="number">0x00000000ff600000</span>)</span><br><span class="line">  to   space 1024K,   <span class="number">0</span>% used [<span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff400000</span>, <span class="number">0x00000000ff500000</span>)</span><br><span class="line"> tenured generation   total 10240K, used 8820K [<span class="number">0x00000000ff600000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">   the space 10240K,  <span class="number">86</span>% used [<span class="number">0x00000000ff600000</span>, <span class="number">0x00000000ffe9d220</span>, <span class="number">0x00000000ffe9d400</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line"> Metaspace       used 3470K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 379K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>



<h2 id="12、对象是怎么从年轻代进入老年代的？"><a href="#12、对象是怎么从年轻代进入老年代的？" class="headerlink" title="12、对象是怎么从年轻代进入老年代的？"></a>12、对象是怎么从年轻代进入老年代的？</h2><p>存在3种情况：</p>
<p>1、如果对象够老，会通过提升（Promotion）进入老年代，这一般是根据对象的年龄进行判断的。</p>
<p>2、动态对象年龄判定。有的垃圾回收算法，比如G1，并不要求age必须达到15才能晋升到老年代，它会使用一些动态的计算方法。</p>
<p>3、超出某个大小的对象将直接在老年代分配。不过这个值默认为0，意思是全部首选Eden区进行分配。</p>
<h2 id="13、简单描述一下（分代）垃圾回收的过程？-高频"><a href="#13、简单描述一下（分代）垃圾回收的过程？-高频" class="headerlink" title="13、简单描述一下（分代）垃圾回收的过程？(高频)"></a>13、简单描述一下（分代）垃圾回收的过程？(高频)</h2><p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840096.png" alt="img"></p>
<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1&#x2F;3，老生代的默认占比是2&#x2F;3。</p>
<p>新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>
<p>当年轻代中的Eden区分配满的时候，就会触发年轻代的GC（Minor GC）。具体过程如下：</p>
<p>1、在Eden区执行了第一次GC之后，存活的对象会被移动到其中一个Survivor分区（以下简称to）</p>
<p>2、From区中的对象根据对象的年龄值决定去向，达到阈值15移动到老年代，没有达到复制到to区域(复制算法)</p>
<p>3、在把Eden和to区中的对象清空掉</p>
<h2 id="14、JVM的永久代中会发生垃圾回收么？"><a href="#14、JVM的永久代中会发生垃圾回收么？" class="headerlink" title="14、JVM的永久代中会发生垃圾回收么？"></a>14、JVM的永久代中会发生垃圾回收么？</h2><p>永久代会触发垃圾回收的，如果永久代满了或者是超过了临界值，会触发完全垃圾回收（Full GC）。</p>
<p>注：Java 8 中已经移除了永久代，新加了一个叫做元数据区(Metaspace)的内存区。</p>
<h1 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4 垃圾收集器"></a>4 垃圾收集器</h1><h2 id="15、常见的垃圾收集器都有哪些？-高频"><a href="#15、常见的垃圾收集器都有哪些？-高频" class="headerlink" title="15、常见的垃圾收集器都有哪些？(高频)"></a>15、常见的垃圾收集器都有哪些？(高频)</h2><p>串行:</p>
<p>​	单线程</p>
<p>​	堆内存较小，适合个人电脑</p>
<p>吞吐量优先：</p>
<p>​	多线程</p>
<p>​	堆内存较大，多核cpu,适合服务器</p>
<p>​	单位时间内，STW时间最短</p>
<p>响应时间优先:</p>
<p>​	多线程</p>
<p>​	堆内存较大，多cpu,适合服务器</p>
<p>​	单次STW时间越短越好</p>
<p>常见的垃圾收集器如下所示：</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840291.png" alt="img"></p>
<p>不同的垃圾收集器，作用的堆内存空间是不一样的；上面的  serial ， parnew ， Paraller Scavenge 是新生代的垃圾回收器；CMS ， Serial Old ，Paralle Old是老年代的垃圾收集器 ， G1垃圾收集器可以作用于新生代和老年代； 连线表示垃圾收集器可以搭配使用；</p>
<p><strong>① Serial</strong></p>
<p>特点：</p>
<ol>
<li><p>Serial是一个单线程的垃圾收集器</p>
</li>
<li><p>“Stop The World”，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。在用户不可见的情况下把用户正常工作的线程全部停掉。</p>
</li>
</ol>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840241.png" alt="img"></p>
<p>应用场景：</p>
<ol>
<li><p>使用场景：多用于桌面应用，Client端的垃圾回收器</p>
</li>
<li><p>桌面应用内存小，进行垃圾回收的时间比较短，只要不频繁发生停顿就可以接受</p>
</li>
</ol>
<p>Serial Old收集器是Serial的老年代版本和Serial一样是单线程，使用的算法是”标记-整理”</p>
<p><strong>② ParNew</strong></p>
<p>概述: ParNew 收集器其实就是 Serial 收集器的多线程版本</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840352.png" alt="img"></p>
<p>特点：</p>
<p>1、会触发stop the world</p>
<p>2、多线程方式进行垃圾回收</p>
<p>应用场景：它却是许多运行在 Server 模式下的虚拟机中首选的新生代收集器</p>
<p>注意：如果是单核cpu即使使用该垃圾回收器也无法提高执行效率</p>
<p><strong>③ Parallel Scavenge</strong></p>
<p>概述：Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p>
<p>特点：由于与吞吐量关系密切，Parallel Scavenge 收集器也经常称为“吞吐量优先”收集器</p>
<p>所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即<strong>吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）</strong>，虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%</p>
<p>应用场景： 高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel old收集器Parallel Scavenge收集器的老年代版本，使用多线程+标记整理算法</p>
<p><strong>④ CMS(重点)</strong></p>
<p>概述：CMS  (Concurrent Mark Sweep）收集器是-种以获取最短回收停顿时间为目标的收集器。</p>
<p>特点：</p>
<ol>
<li><p>CMS 收集器是基于“标记-清除”算法实现的 </p>
</li>
<li><p>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上,这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好<br>   的体验。</p>
</li>
</ol>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840411.png" alt="img"></p>
<p>步骤流程：</p>
<ul>
<li><p>初始标记（CMS initial mark)——– 标记一下 GC Roots 能直接关联到的对象，速度很快（stop the world）</p>
</li>
<li><p>并发标记（CMS concurrent mark）——– 对初始标记标记过的对象，进行trace（进行追踪，得到所有关联的对象，进行标记）</p>
</li>
<li><p>重新标记（CMS remark)——– 为了修正并发标记期间因用户程序导致标记产生变动的标记记录（stop the world）</p>
</li>
<li><p>并发清除（CMS concurrent sweep)</p>
</li>
</ul>
<p>缺点：会产生垃圾碎片</p>
<p><strong>⑤ G1</strong>：Garbage First&#x2F;One</p>
<p>概述： G1是一个分代的，并行与并发的”<strong>标记-整理</strong>“垃圾回收器。 它的设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p>相比于CMS：</p>
<p>​	1、G1垃圾回收器使用的是”标记-整理”，因此其回收得到的空间是连续的。 </p>
<p>​	2、G1回收器的内存与CMS回收器要求的内存模型有极大的不同。G1将内存划分一个个固定大小的region，每个region可以是年轻代、老年代的一个。内存的回收是以region作为基本单位的； </p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840459.png" alt="img"></p>
<h2 id="16、你都用过G1垃圾回收器的哪几个重要参数？"><a href="#16、你都用过G1垃圾回收器的哪几个重要参数？" class="headerlink" title="16、你都用过G1垃圾回收器的哪几个重要参数？"></a>16、你都用过G1垃圾回收器的哪几个重要参数？</h2><p><strong>① -XX:MaxGCPauseMillis</strong></p>
<p>暂停时间，默认值200ms。这是一个软性目标，G1会尽量达成，如果达不成，会逐渐做自我调整。</p>
<p><strong>② -XX:G1HeapRegionSize</strong></p>
<p>Region大小，若未指定则默认最多生成2048块，每块的大小需要为2的幂次方，如1,2,4,8,16,32，最大值为32M。</p>
<p><strong>③ -XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent</strong></p>
<p>新生代比例有两个数值指定，下限：-XX:G1NewSizePercent，默认值5%，上限：-XX:G1MaxNewSizePercent，默认值60%。</p>
<h2 id="17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？"><a href="#17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？" class="headerlink" title="17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？"></a>17、串行（serial）收集器和吞吐量（throughput）收集器的应用场景？</h2><p>吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。 而串行收集器对大多数的小应用（在现代处理器上需要大概 100M 左右的内存）就足够了。</p>
<h2 id="18、生产上如何配置垃圾收集器的？"><a href="#18、生产上如何配置垃圾收集器的？" class="headerlink" title="18、生产上如何配置垃圾收集器的？"></a>18、生产上如何配置垃圾收集器的？</h2><p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840851.png" alt="img"></p>
<p>1、首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。通常，堆空间我会设置成操作系统的2&#x2F;3（这是想给其他进程和操作系统预留一些时间），超过8GB的堆优先选用G1。</p>
<p>2、接下来，我会对JVM进行初步优化。比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例。</p>
<p>3、再接下来，就是专项优化，主要判断的依据就是系统容量、访问延迟、吞吐量等。我们的服务是高并发的，所以对STW的时间非常敏感。我会通过记录</p>
<p>详细的GC日志，来找到这个瓶颈点，借用<strong>gceasy（重点）</strong><a href="https://gceasy.io/%E8%BF%99%E6%A0%B7%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%BE%88%E5%AE%B9%E6%98%93%E5%AE%9A%E4%BD%8D%E5%88%B0%E9%97%AE%E9%A2%98%E3%80%82%E4%B9%8B%E6%89%80%E4%BB%A5%E9%80%89%E6%8B%A9%E9%87%87%E7%94%A8%E5%B7%A5%E5%85%B7%EF%BC%8C%E6%98%AF%E5%9B%A0">https://gceasy.io/这样的日志分析工具，很容易定位到问题。之所以选择采用工具，是因</a></p>
<p>为gc日志看起来实在是太麻烦了，gceasy号称是AI学习分析问题，可视化做的较好。</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840815.png" alt="img"></p>
<h1 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5 类加载器"></a>5 类加载器</h1><h2 id="19、什么是类加载器，类加载器有哪些？-高频"><a href="#19、什么是类加载器，类加载器有哪些？-高频" class="headerlink" title="19、什么是类加载器，类加载器有哪些？(高频)"></a>19、什么是类加载器，类加载器有哪些？(高频)</h2><p>类加载器的作用：负载将的class文件加载到java虚拟机中，并为之创建一个Class对象	</p>
<p>​	1、 启动类加载器（Bootstrap class loader）：它是虚拟机的内置类加载器，通过表示为null </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载 JAVA_HOME/jre/lib目录</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	2、 平台类加载器（Platform class loader）  ：它是平台类加载器； 负责加载JDK中一些特殊的模块； </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载 JAVA_HOME/jre/lib/ext目录</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	3、 系统类加载器（System class loader）   ：它也被称为应用程序类加载器， 它负责加载用户类路径上所指定的类库，一般情况下这个就是程序中默认的类加载器 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加载classpath目录</span><br></pre></td></tr></table></figure>

<h2 id="20、Java的双亲委托机制是什么？-高频"><a href="#20、Java的双亲委托机制是什么？-高频" class="headerlink" title="20、Java的双亲委托机制是什么？(高频)"></a>20、Java的双亲委托机制是什么？(高频)</h2><p><strong>概述</strong></p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840065.png" alt="img" style="zoom: 150%;">

<p>类加载器之间的层次关系，就称之为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这里的类加载器的父子关系不是真正物理意义上的继承，而是逻辑上的继承。</p>
<p><strong>工作过程</strong></p>
<p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传说到顶层的启动类加载器中，只有当父类加载器返回自己无法完成这个加载请求（它的搜索返回中没有找到所需的类）时，子类加载器才会尝试自己去加载。</p>
<h1 id="6-性能调优"><a href="#6-性能调优" class="headerlink" title="6 性能调优"></a>6 性能调优</h1><h2 id="21、调优命令有哪些？"><a href="#21、调优命令有哪些？" class="headerlink" title="21、调优命令有哪些？"></a>21、调优命令有哪些？</h2><p>1、<strong>jps</strong>，JVM Process Status Tool显示指定系统内所有的HotSpot虚拟机进程。</p>
<p>2、<strong>jstat</strong>，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<p>查询帮助文档：jstat -options</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840109.png" alt="img"></p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840208.png" alt="img"></p>
<p>3、<strong>jmap</strong>，JVM Memory Map命令用于查看<strong>堆内存</strong>的分配情况以及生成heap dump文件</p>
<p>查询帮助文档：jmap -h</p>
<p>示例1：jmap -heap 33193 查询堆内存的分配情况</p>
<p>示例2：jmap -dump:format&#x3D;b,file&#x3D;thread-cup.log 33193</p>
<p>4、<strong>jhat</strong>，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP&#x2F;HTML服务器，生成dump的分析结果后，可以在浏览器中查看</p>
<p>查询帮助文档：</p>
<p>jhat -h</p>
<p>示例：jhat -J-Xmx512M thread-cup.log</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840336.png" alt="img"></p>
<p>5、<strong>jstack</strong>，用于生成java虚拟机当前时刻的线程快照。</p>
<p>查看帮助文档：jstack -h</p>
<p>示例：jstack -l 33193</p>
<p>6、<strong>jinfo</strong>，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。</p>
<p>查看帮助文档：jinfo -h</p>
<p>示例：jinfo -flags 33193</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306191840530.png" alt="img"></p>
<h2 id="22、你知道哪些JVM性能调优参数？-高频"><a href="#22、你知道哪些JVM性能调优参数？-高频" class="headerlink" title="22、你知道哪些JVM性能调优参数？(高频)"></a>22、你知道哪些JVM性能调优参数？(高频)</h2><p>1、设定堆内存大小：</p>
<p>​	-Xms	设置最小堆内存大小(不能小于1024K); 	-Xms 堆内存初始大小，可以通过jmap工具进行查看</p>
<p>​	-Xmx	设置最大堆内存大小(不能小于1024K);   -Xmx 堆内存最大值，可以通过jmap工具进行查看</p>
<p>2、设定新生代大小：</p>
<p>​	-XX:NewSize：新生代大小</p>
<p>​	-XX:NewRatio 新生代和老生代占比</p>
<p>3、-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比</p>
<p>4、设定垃圾回收器</p>
<p>​	年轻代用 -XX:+UseParNewGC</p>
<p>​	年老代用-XX:+UseConcMarkSweepGC</p>
<h2 id="23、你用过哪些性能调优工具？-高频"><a href="#23、你用过哪些性能调优工具？-高频" class="headerlink" title="23、你用过哪些性能调优工具？(高频)"></a>23、你用过哪些性能调优工具？(高频)</h2><p>常用调优工具分为两类</p>
<p>1、jdk自带监控工具</p>
<ul>
<li><p>jconsole，Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控 </p>
</li>
<li><p>jvisualvm，jdk自带全能工具，可以分析内存快照、线程快照；监控内存变化、GC变化等。</p>
</li>
</ul>
<p>2、第三方</p>
<ul>
<li>GChisto，一款专业分析gc日志的工具</li>
</ul>
<h2 id="24、你都有哪些手段用来排查内存溢出？-高频"><a href="#24、你都有哪些手段用来排查内存溢出？-高频" class="headerlink" title="24、你都有哪些手段用来排查内存溢出？(高频)"></a>24、你都有哪些手段用来排查内存溢出？(高频)</h2><p>内存溢出包含很多种情况，我在平常工作中遇到最多的就是堆溢出。有一次线上遇到故障，重新启动后，使用<strong>jstat</strong>命令，发现Old区在一直增长。我使用<strong>jmap</strong>命令，导出了一份线上堆栈，然后使用MAT进行分析。通过对GC Roots的分析，我发现了一个非常大的HashMap对象，这个原本是有位同事做缓存用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 Guava Cache，并设置了软引用，故障就消失了。</p>
<p>①jps： JVM Process Status Tool显示指定系统内所有的HotSpot虚拟机进程</p>
<p>②jstat： Java Virtual Machine Statistics Monitoring Tool,是JDK提供的一个可以监控Java虚拟机各种运行状态信息的命令行工具。它可以显示Java虚拟机中的类加载、内存、垃圾收集、即时编译等运行状态的信息。</p>
<p>③jstack：用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等</p>
<p>④jconsole：Java Monitoring and Management Console是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控</p>
<h2 id="25、导致内存溢出的原因"><a href="#25、导致内存溢出的原因" class="headerlink" title="25、导致内存溢出的原因"></a>25、导致内存溢出的原因</h2><p>1、内存泄漏：当对象不再使用时，没有及时释放对应的内存资源，导致内存不断积累，最终耗尽可用内存空间。</p>
<p>2、频繁创建大量对象：如果应用程序频繁创建大量的对象，而没有及时释放这些对象，会导致内存使用量不断增加，最终导致内存溢出。</p>
<p>3、静态集合类引起的内存泄漏：如果使用静态集合类（如静态List、Map等）来保存大量对象，并且没有适时地清理或移除这些对象，会导致内存泄漏。</p>
<p>4、递归调用导致的栈溢出：当递归调用的深度过大时，会导致栈空间耗尽，进而导致栈溢出错误。</p>
<h2 id="26、解决内存溢出（OOM）的方法"><a href="#26、解决内存溢出（OOM）的方法" class="headerlink" title="26、解决内存溢出（OOM）的方法"></a>26、解决内存溢出（OOM）的方法</h2><p>1、内存泄漏排查：使用内存分析工具（如 jvisualvm 等）来检测和分析内存泄漏问题。通过查看对象的引用链和内存占用情况，找出引起内存泄漏的根本原因，并进行相应的修复。</p>
<p>2、优化对象的创建和销毁：减少不必要的对象创建和使用，及时释放不再使用的对象。使用对象池或缓存来管理对象的创建和重用，减少对象频繁创建和销毁带来的内存开销。</p>
<p>3、增加堆内存：通过增加JVM的堆内存限制，提高可用内存空间。可以通过调整JVM的启动参数中的-Xms（初始堆大小）和-Xmx（最大堆大小）来设置堆内存大小。</p>
<p>4、使用合适的集合和数据结构：根据实际需求选择合适的集合和数据结构，避免使用静态集合类保存大量对象。及时清理和移除不再需要的对象，防止内存泄漏。</p>
<p>5、优化递归算法：检查和优化递归算法，确保递归调用的深度合理且不会导致栈溢出。可以考虑使用迭代或尾递归等替代递归的方式来避免栈溢出问题。</p>
<p>6、监控和调优：使用性能监控工具对应用程序进行实时监控，查看内存使用情况和垃圾回收行为。根据监控结果进行相应的优化和调整，如调整垃圾回收器参数、调整内存分配策略等。</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab部署</title>
    <url>/GitLab%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>非私有化访问</p>
<p>方式：注册GitLab</p>
<p><a href="https://blog.csdn.net/m0_50542823/article/details/135495927">https://blog.csdn.net/m0_50542823/article/details/135495927</a></p>
<p>私有化部署</p>
<p>1、使用 docker-compose 配置 gitlab</p>
<p>安装docker-compose 之前需安装 docker </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo  添加镜像源</span><br><span class="line"></span><br><span class="line">yum install -y https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/docker-ce-cli-18.09.3-3.el7.x86_64.rpm  先安装docker-ce-cli，因为先安装docker-ce，会自动升级为新版本</span><br><span class="line"></span><br><span class="line">yum install -y https://mirrors.aliyun.com/docker-ce/linux/centos/7/x86_64/edge/Packages/docker-ce-18.09.3-3.el7.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除 docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove -y docker-ce containerd.io </span><br><span class="line">yum remove -y docker-ce-cli containerd.io </span><br><span class="line">yum remove -y docker-ce docker-ce-cli </span><br><span class="line"></span><br><span class="line">sudo rm -rf /var/lib/docker</span><br><span class="line">sudo rm -rf /etc/docker</span><br></pre></td></tr></table></figure>



<p>2、安装 docker-compose</p>
<p>使用 pip安装 docker-compose</p>
<p>pip install –upgrade pip -i <a href="http://mirrors.aliyun.com/pypi/simple">http://mirrors.aliyun.com/pypi/simple</a> –trusted-host mirrors.aliyun.com<br>pip install -i <a href="http://mirrors.aliyun.com/pypi/simple">http://mirrors.aliyun.com/pypi/simple</a> docker-compose –trusted-host mirrors.aliyun.com</p>
<p>3、安装gitlab</p>
<p><a href="https://juejin.cn/post/7302330573380698124?searchId=2024051521061446EA80D193F1E6BD118E#heading-4">https://juejin.cn/post/7302330573380698124?searchId=2024051521061446EA80D193F1E6BD118E#heading-4</a></p>
<p>修改 docker-compose.yml 文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;  </span><br><span class="line">services:  </span><br><span class="line">  gitlab:  </span><br><span class="line">    image: &#x27;gitlab/gitlab-ce:latest&#x27;  </span><br><span class="line">    container_name: gitlab  </span><br><span class="line">    restart: always </span><br><span class="line">    hostname: &#x27;127.0.0.1&#x27;   </span><br><span class="line">    privileged: true  </span><br><span class="line">    environment:  </span><br><span class="line">      TZ: &#x27;Asia/Shanghai&#x27;  </span><br><span class="line">      GITLAB_OMNIBUS_CONFIG: |  </span><br><span class="line">        external_url &#x27;http://192.168.223.129:30080&#x27; # 将&lt;YOUR_HOST_OR_IP&gt;替换为宿主机的IP或域名  </span><br><span class="line">        gitlab_rails[&#x27;registry_external_url&#x27;] = &#x27;http://192.168.223.129:30080&#x27; # 修正registry_external_url的语法  </span><br><span class="line">        gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;  </span><br><span class="line">      GITLAB_ROOT_PASSWORD: &#x27;***&#x27;  </span><br><span class="line">    ports:  </span><br><span class="line">      - &#x27;30080:30080&#x27; </span><br><span class="line">      - &#x27;443:443&#x27; # 如果你打算使用HTTPS，确保你的证书和配置都正确设置  </span><br><span class="line">      - &#x27;2222:22&#x27;</span><br><span class="line">    volumes:  </span><br><span class="line">      - &#x27;./gitlab/config:/etc/gitlab&#x27;  </span><br><span class="line">      - &#x27;./gitlab/logs:/var/log/gitlab&#x27;  </span><br><span class="line">      - &#x27;./gitlab/data:/var/opt/gitlab&#x27;  </span><br><span class="line">    shm_size: &#x27;256m&#x27; </span><br><span class="line"></span><br><span class="line">在Docker Compose文件中，端口映射的格式是 宿主机端口:容器端口。在你给出的配置中，- &#x27;30080:80&#x27; 表示将宿主机的30080端口映射到容器的80端口。</span><br><span class="line"></span><br><span class="line">30080 是宿主机端口（Host port）：这是你希望外部系统（例如你的电脑、网络中的其他计算机或服务）访问GitLab时所使用的端口。</span><br><span class="line">80 是容器端口（Container port）：这是GitLab容器内部监听HTTP请求的端口。GitLab默认使用80端口作为HTTP服务的端口（当然，这可以通过GitLab的配置进行更改）。</span><br></pre></td></tr></table></figure>

<p>修改 gitlab.rb文件 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line"></span><br><span class="line">修改以下</span><br><span class="line">external_url &#x27;http://192.168.223.129:30080&#x27;</span><br></pre></td></tr></table></figure>



<p>启动 docker-compose</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d 在docker-compose.yaml文件所在目录启动</span><br></pre></td></tr></table></figure>

<p>启动成功后，在网页中打开gitlab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.223.129:30080/  宿主机IP:30080</span><br></pre></td></tr></table></figure>

<p>账号 root 密码 为 docker-compose.yml 中配置的密码</p>
<p>部署过程</p>
<p><a href="https://juejin.cn/post/7341315113158541327?searchId=20240516094045F1A6EB08ED9E44FC82BE">https://juejin.cn/post/7341315113158541327?searchId=20240516094045F1A6EB08ED9E44FC82BE</a></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库</title>
    <url>/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="sql语句的分类"><a href="#sql语句的分类" class="headerlink" title="sql语句的分类"></a>sql语句的分类</h3><p>DDL：数据定义语言。用来操作数据库，表，列等。<br>DML：数据操作语言。用来对数据库中表的数据进行增删改。<br>DQL：数据查询语言。用来查询数据库中表的记录（数据）。<br>DCL：数据控制语言。用来定义数据库的访问权限和安全级别，及创建用户。</p>
<h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><h4 id="DDL查询和创建数据库"><a href="#DDL查询和创建数据库" class="headerlink" title="DDL查询和创建数据库"></a>DDL查询和创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、查询所有数据库</span><br><span class="line">SHOW DATABASES;</span><br><span class="line">2、查询数据库的创建语句</span><br><span class="line">SHOW CREATE DATABASE 数据库名称</span><br><span class="line">3、创建数据库</span><br><span class="line">CREATE DATABASE 数据库名称：</span><br><span class="line">4、创建数据库（判断，如果不存在则创建）</span><br><span class="line">CREATE DATABASE IF NOT EXISTS 数据库名称</span><br><span class="line">5、创建数据库（指定字符集）</span><br><span class="line">CREATE DATABASE 数据库名称 CHARACTERSET 字符集名称：</span><br></pre></td></tr></table></figure>

<h4 id="DDL修改、删除、使用数据库"><a href="#DDL修改、删除、使用数据库" class="headerlink" title="DDL修改、删除、使用数据库"></a>DDL修改、删除、使用数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、修改数据库（修改字符集）</span><br><span class="line">ALTER DATABASE 数据库名称 CHARACTERSET 字符集名称：</span><br><span class="line">2、删除数据库</span><br><span class="line">DROP DATABASE 数据库名称：</span><br><span class="line">3、删除数据库（判断，如果存在则删除）</span><br><span class="line">DROP DATABASE IF EXISTS 数据库名称：</span><br><span class="line">4、使用数据库</span><br><span class="line">USE 数据库名称</span><br><span class="line">5、查看当前使用的数据库</span><br><span class="line">SELECT DATABASE()</span><br></pre></td></tr></table></figure>

<h4 id="DDL查询表"><a href="#DDL查询表" class="headerlink" title="DDL查询表"></a>DDL查询表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、查询所有的数据表</span><br><span class="line">SHOW TABLES;</span><br><span class="line">2、查询表结构</span><br><span class="line">DESC 表名</span><br><span class="line">3、查询表字符集</span><br><span class="line">SHOW TABLE STATUS FROM 库名 LIKE &#x27;表名&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="DDL创建表"><a href="#DDL创建表" class="headerlink" title="DDL创建表"></a>DDL创建表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 约束,</span><br><span class="line">	列名 数据类型 约束.</span><br><span class="line">	........</span><br><span class="line">	列名 数据类型 约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>数据类型：</p>
<p>​	tinynit：整数类型，数据范围0-255</p>
<p>​	int：整数类型,主键字段</p>
<p>​	bigint：特殊场景的主键字段</p>
<p>​	double：小数类型</p>
<p>​	double(M,D)	M：整数部位+小数部位    D：小数部位</p>
<p>​	date：日期类型。包含年月日，格式yyyy-MM-dd<br>​	datetime：日期类型。包含年月日时分秒，格式yyyy-MM-ddHH:mm:ss<br>​	timestamp：时i间戳类型。包含年月日时分秒，格式yyyy-MM-ddHH:mmss<br>​							*如果不给该列赋值、或赋值为null，则默认使用当前系统时间自动赋值<br>​	varchar(长度)：字符串类型，不固定长度</p>
<p>​	char：字符串类型，固定长度</p>
<p>​	text或longtext：长文本存储</p>
<p>​	decimal：金额字段</p>
<p>&#x3D;&#x3D;sql 语句不区分大小写。&#x3D;&#x3D;</p>
<h4 id="DDL修改数据表"><a href="#DDL修改数据表" class="headerlink" title="DDL修改数据表"></a>DDL修改数据表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、修改表名</span><br><span class="line">ALTER TABLE 表名 RENAME TO 新表名</span><br><span class="line">2、修改表的字符集</span><br><span class="line">ALTER TABLE 表名 CHARACTERSET 字符集名称：</span><br><span class="line">3、单独添加一列</span><br><span class="line">ALTER TABLE 表名 ADD 列名 数据类型</span><br><span class="line">4、修改某列的数据类型</span><br><span class="line">ALTER TABLE 表名 MODIFY 列名 新数据类型</span><br><span class="line">5、修改列名和数据类型</span><br><span class="line">ALTER TABLE 表名 CHANGE 列名 新列名 新数据类型</span><br><span class="line">6、删除某一列</span><br><span class="line">ALTER TABLE 表名 DROP 列名</span><br></pre></td></tr></table></figure>

<h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、删除数据表</span><br><span class="line">DROP TABLE 表名；</span><br><span class="line">2、删除数据表（判断，如果存在则删除）</span><br><span class="line">DROP TABLE IF EXISTS 表名</span><br></pre></td></tr></table></figure>



<h4 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE A AS SELECT * FROM B;</span><br><span class="line">创建表 A ，并将 表B 的数据全部复制到表 A.</span><br></pre></td></tr></table></figure>

<p>表 B  的数据复制进来后，A 表将不会被任何后来的数据覆盖。</p>
<h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><h4 id="DML新增数据"><a href="#DML新增数据" class="headerlink" title="DML新增数据"></a>DML新增数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、给指定列添加数据</span><br><span class="line">INSERT INTO 表名 (列名1，列名2...)VALUES(值1，值2...)</span><br><span class="line">2、给全部列添加数据</span><br><span class="line">INSERT INTO 表名 VALUES(值1，值2...)</span><br><span class="line">3、批量新增数据</span><br><span class="line">INSERT INTO 表名 (列名1，列名2...)VALUES(值1，值2...),(值1，值2...)...;</span><br><span class="line">INSERT INTO 表名 VALUES(值1，值2...),(值1，值2...)....;</span><br></pre></td></tr></table></figure>

<h4 id="DML修改和删除表数据"><a href="#DML修改和删除表数据" class="headerlink" title="DML修改和删除表数据"></a>DML修改和删除表数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、修改表中的数据</span><br><span class="line">UPDATE 表名 SET 列名1=值1，列名2=值2...[WHERE 条件]</span><br><span class="line">修改语句中必须加条件，如果不加条件，则会将所有数据都修改。</span><br><span class="line">2、删除表中的数据</span><br><span class="line">DELETE FROM 表名 [WHERE 条件]:</span><br><span class="line">删除语句中必须加条件，如果不加条件，则会将所有数据都删除。</span><br></pre></td></tr></table></figure>

<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>char( )</td>
<td>1～255个字符的定长串。</td>
</tr>
<tr>
<td>varchar</td>
<td>长度可变，最多不超过255字节</td>
</tr>
<tr>
<td>text</td>
<td>最大长度为64 K的变长文本</td>
</tr>
<tr>
<td>int</td>
<td>整数值，支持 -2的31次方~ 2的31次方-1（如果是UNSIGNED(无符号)，为0～4294967295）的数</td>
</tr>
<tr>
<td>bigint</td>
<td>整数值，支持 -2的63次方~ 2的63次方-1</td>
</tr>
<tr>
<td>tinyint</td>
<td>整数值，支持 -128～127  (如果是UNSIGNED(无符号)，为0～255 )</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔值</td>
</tr>
<tr>
<td>decimal( )</td>
<td>精度可变的浮点值</td>
</tr>
</tbody></table>
<h3 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h3><h3 id="SQL-查询语句执行顺序"><a href="#SQL-查询语句执行顺序" class="headerlink" title="SQL 查询语句执行顺序"></a>SQL 查询语句执行顺序</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	字段表</span><br><span class="line">FROM</span><br><span class="line">	表名列表</span><br><span class="line">WHERE</span><br><span class="line">	条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">	分组字段</span><br><span class="line">HAVING</span><br><span class="line">	分组后的过滤条件</span><br><span class="line">ORDER BY</span><br><span class="line">	排序</span><br><span class="line">LIMIT</span><br><span class="line">	分页</span><br></pre></td></tr></table></figure>

<h4 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、查询全部的表数据</span><br><span class="line">SELECT * FROM 表名</span><br><span class="line">2、查询指定字段的表数据</span><br><span class="line">SELECT 列名1，列名2，FROM 表名</span><br><span class="line">3、去除重复查询</span><br><span class="line">SELECT DISTINCT 列名1，列名2...FROM 表名</span><br><span class="line">4、计算列的值（四则运算）</span><br><span class="line">SELECT 列名1 运算符(+-*/)列名2 FROM 表名</span><br><span class="line">5、起别名查询</span><br><span class="line">SELECT 列名 AS 别名 FROM 表名  	 AS可省略</span><br></pre></td></tr></table></figure>

<h4 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h4><p>DISTINCT </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT 列名1，列名2...FROM 表名</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;DISTINCT 需要放到所有列名的前面，如果写成 SELECT 列名1, DISTINCT 列名2 FROM 表 会报错。&#x3D;&#x3D;</p>
<p>WHERE </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">    university,</span><br><span class="line">    round(avg(question_cnt), 3) as avg_question_cnt,</span><br><span class="line">    round(avg(answer_cnt), 3) as avg_answer_cnt</span><br><span class="line">from</span><br><span class="line">    user_profile</span><br><span class="line">group by</span><br><span class="line">    university</span><br><span class="line">having</span><br><span class="line">    avg_question_cnt &lt; 5</span><br><span class="line">    or avg_answer_cnt &lt; 20</span><br></pre></td></tr></table></figure>

<p>不能写为下面SQL的原因，WHERE 后面使用了聚合函数的结果，但是<code>WHERE</code> 子句是在聚合之前运行的，所以该语句错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	university,</span><br><span class="line">	round ( avg( question_cnt ), 3 ) AS avg_question_cnt,</span><br><span class="line">	round ( avg( answer_cnt ), 3 ) AS avg_answer_cnt </span><br><span class="line">FROM</span><br><span class="line">	user_profile </span><br><span class="line">WHERE</span><br><span class="line">	avg_question_cnt &lt; 5 </span><br><span class="line">	OR avg_answer_cnt &lt; 20</span><br></pre></td></tr></table></figure>







<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>WHERE</p>
<h6 id><a href="#" class="headerlink" title></a></h6><table>
<thead>
<tr>
<th>符号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt;或 !&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td>BETWEEN…AND…</td>
<td>在什么和什么之间  例：WHERE age BETWEEN 20 AND  30</td>
</tr>
<tr>
<td>IN(1,2…..)</td>
<td>多选</td>
</tr>
<tr>
<td>LIKE 占位符</td>
<td>模糊查询，_单个任意字符，%多个任意字符</td>
</tr>
<tr>
<td>IS NULL</td>
<td>是NULL   例： WHERE name IS NULL</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>不是NULL   例：  WHERE name IS NOT NULL</td>
</tr>
<tr>
<td>AND 或 &amp;&amp;</td>
<td>并且   例：WHERE age &gt;20 AND age &lt;30</td>
</tr>
<tr>
<td>OR 或||</td>
<td>或</td>
</tr>
<tr>
<td>NOT 或 !</td>
<td>非  例： WHERE NOT age &#x3D; 20</td>
</tr>
</tbody></table>
<h6 id="IF-条件判断函数"><a href="#IF-条件判断函数" class="headerlink" title="IF 条件判断函数"></a>IF 条件判断函数</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF (condition, value_if_true, value_if_false)</span><br><span class="line">参数1 为条件，如果条件成立返回参数2 ，不成立返回参数3</span><br></pre></td></tr></table></figure>



<h6 id="IFNULL-判断函数"><a href="#IFNULL-判断函数" class="headerlink" title="IFNULL 判断函数"></a>IFNULL 判断函数</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFNULL(参数一，参数二)</span><br><span class="line">如果第一个值为null ,则返回第二个值；如果第一个值不为null ，则返回第一个值。</span><br><span class="line">SELECT id,name,IFNULL(price,0)+10 from food;   如果price为null，则替换为0，然后给price+10</span><br></pre></td></tr></table></figure>



<h6 id="OR和AND的使用"><a href="#OR和AND的使用" class="headerlink" title="OR和AND的使用"></a>OR和AND的使用</h6><p>&#x3D;&#x3D;OR 和 AND 同时使用时，SQL会先处理 AND，所以在使用时应该将 OR 语句用（）括起来。&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	* </span><br><span class="line">FROM</span><br><span class="line">	customers </span><br><span class="line">WHERE</span><br><span class="line">	(cust_state = &#x27;OH&#x27; </span><br><span class="line">	OR cust_state = &#x27;CA&#x27; )</span><br><span class="line">	AND cust_id &gt; 1000000003;</span><br></pre></td></tr></table></figure>



<h6 id="单引号的使用"><a href="#单引号的使用" class="headerlink" title="单引号的使用"></a>单引号的使用</h6><p>&#x3D;&#x3D;当与字符串类型的列相比较时，需要引号。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;当与数值类型的列相比较时，不需要引号。&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM user WHERE name = &#x27;xiaoming&#x27;;</span><br><span class="line">SELECT * FROM user WHERE age &lt; 30;</span><br></pre></td></tr></table></figure>

<h6 id="含有NULL-的查询"><a href="#含有NULL-的查询" class="headerlink" title="含有NULL 的查询"></a>含有NULL 的查询</h6><p>有些数据为NULL ，查询出来的结果可能不包含含有NULL 的这行数据。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>state</th>
</tr>
</thead>
<tbody><tr>
<td>BRE02</td>
<td>OH</td>
</tr>
<tr>
<td>BRS01</td>
<td>MI</td>
</tr>
<tr>
<td>DLL01</td>
<td>CA</td>
</tr>
<tr>
<td>FNG01</td>
<td>(null)</td>
</tr>
<tr>
<td>FRB01</td>
<td>NY</td>
</tr>
<tr>
<td>JTS01</td>
<td>(null)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM vendors WHERE vend_state != &#x27;MI&#x27;;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>id</th>
<th>state</th>
</tr>
</thead>
<tbody><tr>
<td>BRE02</td>
<td>OH</td>
</tr>
<tr>
<td>DLL01</td>
<td>CA</td>
</tr>
<tr>
<td>FRB01</td>
<td>NY</td>
</tr>
</tbody></table>
<h6 id="IN和OR-的区别"><a href="#IN和OR-的区别" class="headerlink" title="IN和OR 的区别"></a>IN和OR 的区别</h6><p>IN 比 OR 执行速度快；</p>
<p>IN 里面可以包含其他 SELECT 语句。</p>
<h6 id="LIKE-的使用"><a href="#LIKE-的使用" class="headerlink" title="LIKE 的使用"></a>LIKE 的使用</h6><p>LIKE 只能用于字符串类型，不能用于数值类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WHERE prod_name LIKE &#x27;fish%&#x27;;</span><br></pre></td></tr></table></figure>

<p>LIKE 不会匹配 值为 NULL  的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM products WHERE prod_name LIKE &#x27;%&#x27;;</span><br><span class="line">会查询出所有数据非 NULL 的行</span><br></pre></td></tr></table></figure>





<h4 id="聚合函数查询"><a href="#聚合函数查询" class="headerlink" title="聚合函数查询"></a>聚合函数查询</h4><table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count(列名)</td>
<td>统计数量（一般选择不为null 的列）</td>
</tr>
<tr>
<td>max(列名)</td>
<td>最大值</td>
</tr>
<tr>
<td>min(列名)</td>
<td>最小值</td>
</tr>
<tr>
<td>sum(列名)</td>
<td>求和</td>
</tr>
<tr>
<td>avg(列名)</td>
<td>平均值</td>
</tr>
</tbody></table>
<p>avg() 函数 不会统计 含有 NULL 的行，比如共有10个数据， age 字段中有一个数据为 NULL ，则只会计算9个</p>
<p>avg &#x3D; sum(9个数据) &#x2F; 9</p>
<p>聚合函数查询语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 函数名(列名) FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure>

<p>COUNT(*)、COUNT(1)、COUNT(字段)的区别？</p>
<p>COUNT(*) 统计含有NULL 的列统计所有行，包括含有NULL 的行。</p>
<p>COUNT(column) 不会统计含有NULL 的行</p>
<p>一般情况下：COUNT(*) &#x3D; COUNT(1) &gt; COUNT(字段)</p>
<p>如果数据表没有主键，只有一个 column，COUNT(*)最快</p>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名列表 FROM 表名 [WHERE条件] ORDER BY 列名；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名列表 FROM 表名 [WHERE条件] ORDER BY 列名1，列名2</span><br><span class="line">列名1相同，列名2才会排序。当列名1不同时，列名2不会排序。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1，列名2.... FROM 表名 [WHERE条件] ORDER BY 列名1 排序方式，列名2 排序方式....</span><br><span class="line">列名1相同，列名2才会排序。当列名1不同时，列名2不会排序。</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;SELECT 后的列名不需要和 ORDER BY 后的一致。&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1，列名2.... FROM 表名 [WHERE条件] ORDER BY 列名1，列名3</span><br></pre></td></tr></table></figure>

<p>按位置排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1，列名2，列名3 FROM 表名 [WHERE条件] ORDER BY 2</span><br><span class="line">按照SELCET 列表中的位置 ，将 列2 排序。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1，列名2，列名3 FROM 表名 [WHERE条件] ORDER BY 2，3</span><br><span class="line">按照SELCET 列表中的位置 ，先排列2 ，再排列3。</span><br><span class="line">列名2相同，列名3才会排序。当列名2不同时，列名3不会排序。</span><br></pre></td></tr></table></figure>

<p>指定顺序排序</p>
<p>ASC（升序，默认） 、DESC（降序）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名 [WHERE条件] ORDER BY 列名 DESC;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名1，列名2，列名3 FROM 表名 [WHERE条件] ORDER BY 2 ASC，3 DESC;</span><br></pre></td></tr></table></figure>



<p>排序方式：ASC 升序，DESC 降序<br>如果有多个排序条件，只有当前边的条件值一样时，才会判断第二条件。</p>
<h4 id="过滤分组查询"><a href="#过滤分组查询" class="headerlink" title="过滤分组查询"></a>过滤分组查询</h4><p>GROUP BY 分组</p>
<p>HAVING 分组后的条件过滤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名列表 FROM 表名 [WHERE条件] GROUP BY 分组列名1，分组列名2</span><br><span class="line">HAVING 分组后的条件过滤，</span><br></pre></td></tr></table></figure>

<p>group by后给了几个字段，就按照这几个字段组合成一条记录，若有重复的记录，就属于同一组，最后将所有的分组返回。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SNAME,SAGE FROM STUDENT GROUP BY SAGE,SNAME ORDER BY SAGE;</span><br><span class="line">order by后的字段必须来源于group by分组字段。</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202307042100691.png" alt="图片"></p>
<p>&#x3D;&#x3D;在有 order by 排序时，排序字段必须要有索引&#x3D;&#x3D;</p>
<p>HAVING  分组过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id,COUNT(*)orders FROM orders GROUP BY cust_id </span><br><span class="line">查询分组后的cust_id,并统计每一组的数量</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240407113326656.png" alt="image-20240407113326656"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id,COUNT(*)orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;=2;</span><br><span class="line">查询分组之后订单数至少2个的cust_id,并统计每一组的数量</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240407113354275.png" alt="image-20240407113354275"></p>
<p>WHERE 和 HAVING 的区别</p>
<p>WHERE 在分组前过滤，HAVING 在分组后过滤，一个sql 语句中同时有WHERE 和 HAVING ，WHERE 会影响 HAVING 的数据。</p>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名列表 FROM 表名</span><br><span class="line">[WHERE 条件]</span><br><span class="line">[GROUP BY 分组列名]</span><br><span class="line">[HAVING 分组后的条件过滤]</span><br><span class="line">[ORDER BY 排序列名 排序方式]</span><br><span class="line">LIMIT 当前页数，每页显示的条数</span><br></pre></td></tr></table></figure>

<p>当前页数&#x3D; （当前页 - 1）* 3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一页展示的数据</span><br><span class="line">SELECT * FROM TABLE LIMIT 0,3;</span><br><span class="line">第二页展示的数据</span><br><span class="line">SELECT * FROM TABLE LIMIT 3,3</span><br></pre></td></tr></table></figure>



<h4 id="限制结果查询"><a href="#限制结果查询" class="headerlink" title="限制结果查询"></a>限制结果查询</h4><p>LIMIT		只检索前几行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TABLE LIMIT 3;  只查询表中的前三行。</span><br></pre></td></tr></table></figure>

<p>LIMIT   a , b	从第 a 行开始 查询 b 条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TABLE LIMIT 0，3   从第 0 行开始查询3条数据</span><br></pre></td></tr></table></figure>

<p>LIMIT   b  OFFSET   a           从第 a 行开始 查询 b 条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TABLE LIMIT 3 OFFSET 0   从第 0 行开始查询3条数据</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;MySQL 中的第一条数据为 第 0 行。&#x3D;&#x3D;</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--  注释内容</span><br><span class="line"></span><br><span class="line">#  注释内容</span><br></pre></td></tr></table></figure>

<p>多行注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">	注释内容</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<h5 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h5><h6 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h6><table>
<thead>
<tr>
<th>约束</th>
<th>作用</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>PRIMARY KEY</td>
<td>主键约束</td>
<td>非空且唯一、一张表只能有一个主键、一般用作唯一标识</td>
</tr>
<tr>
<td>PRIMARY KEY AUTO_INCREMENT</td>
<td>主键自增</td>
<td>MyQL中的自增约束，必须配合键的约束一起使用</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>唯一约束</td>
<td></td>
</tr>
<tr>
<td>NOT NULL</td>
<td>非空约束</td>
<td></td>
</tr>
<tr>
<td>FOREIGN KEY</td>
<td>外键约束</td>
<td></td>
</tr>
<tr>
<td>FOREIGN KEY ON UPDATE CASCADE</td>
<td>外键级联更新</td>
<td></td>
</tr>
<tr>
<td>FOREIGN KEY ON DELETE CASCADE</td>
<td>外键级联删除</td>
<td></td>
</tr>
</tbody></table>
<h6 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h6><p>建表时添加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型 PRIMARY KEY,</span><br><span class="line">............</span><br><span class="line">列名 数据类型 约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>删除主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP PRIMARY KEY</span><br></pre></td></tr></table></figure>

<p>建表后单独添加主键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 PRIMARY KEY</span><br></pre></td></tr></table></figure>



<h6 id="主键自增"><a href="#主键自增" class="headerlink" title="主键自增"></a>主键自增</h6><p>建表时添加主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">列名 数据类型 PRIMARY KEY AUTO_INCREMENT;</span><br><span class="line">.............</span><br><span class="line">列名 数据类型 约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>删除主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型</span><br></pre></td></tr></table></figure>

<p>建表后单独添加主键自增约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 AUTO INCREMENT</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;MyQL中的自增约束，必须配合键的约束一起使用&#x3D;&#x3D;</p>
<h6 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h6><p>建表时添加唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 UNIQUE,</span><br><span class="line">	.......</span><br><span class="line">	列名 数据类型 约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>删除唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP INDEX 列名</span><br></pre></td></tr></table></figure>

<p>建表后单独添加唯一约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 UNIQUE;</span><br></pre></td></tr></table></figure>



<h6 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h6><p>建表时添加非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名数据 类型 NOT NULL,</span><br><span class="line">	..........</span><br><span class="line">	列名数据 类型 约束</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>删除非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型</span><br></pre></td></tr></table></figure>

<p>建表后单独添加非空约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 列名 数据类型 NOT NULL;</span><br></pre></td></tr></table></figure>



<h6 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h6><p>建表时添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名 数据类型 约束，</span><br><span class="line">	........</span><br><span class="line">	CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名（主表主键列名）</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>删除外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名</span><br></pre></td></tr></table></figure>

<p>建表后单独添加外键约束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD</span><br><span class="line">CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名（主表主键列名）</span><br></pre></td></tr></table></figure>

<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140419453.png" alt="image-20221114041905394" style="zoom:67%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user(</span><br><span class="line">	id int PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE order(</span><br><span class="line">	id int PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	number varchar(20),</span><br><span class="line">	uid int NOT NULL,</span><br><span class="line">	CONSTRAINT order_user FOREIGN KEY (uid) REFERENCES user(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h5 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h5><h6 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h6><p>没有连接条件的表关系，返回的结果为笛卡尔积，结果行数是两张表的行数乘积。</p>
<h6 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h6><p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140656234.png" alt="image-20221114065614174"></p>
<p>身份证和人的一一对应关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE person(</span><br><span class="line">	id int PRIMARY key AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(10)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE card(</span><br><span class="line">	id int PRIMARY key AUTO_INCREMENT,</span><br><span class="line">	card int UNIQUE NOT NULL,</span><br><span class="line">	uid int UNIQUE,</span><br><span class="line">	CONSTRAINT card_person FOREIGN key (uid) REFERENCES person (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT into person VALUES(null,&#x27;zhangsan&#x27;),(null,&#x27;lisi&#x27;),(null,&#x27;wangwu&#x27;);</span><br><span class="line">INSERT into card VALUES(null,12456,1),(null,456489,2),(null,78756,3);</span><br><span class="line"></span><br><span class="line">SELECT person.name,card.card FROM card,person WHERE person.id = card.uid;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140659910.png" alt="image-20221114065956862"></p>
<p>查看关系图</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140712031.png" alt="image-20221114071233976" style="zoom:67%;">

<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140712695.png" alt="image-20221114071253642" style="zoom:67%;">



<h6 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h6><p>适用场景<br>    用户和订单。一个用户可以有多个订单。<br>    商品分类和商品。一个分类下可以有多个商品。<br>建表原则<br>    &#x3D;&#x3D;在多的一方，建立外键约束，来关联一的一方主键。&#x3D;&#x3D;</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140715131.png" alt="image-20221114071546025" style="zoom:67%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user(</span><br><span class="line">	id int PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name varchar(20)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE orderlist(</span><br><span class="line">	id int PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	number varchar(20),</span><br><span class="line">	uid int not NULL,</span><br><span class="line">	CONSTRAINT order_user FOREIGN KEY (uid) REFERENCES user (id)</span><br><span class="line">);</span><br><span class="line">INSERT INTO user VALUES(null,&#x27;张三&#x27;),(null,&#x27;李四&#x27;);</span><br><span class="line">INSERT into orderlist VALUES (null,&#x27;hm001&#x27;,1),(null,&#x27;hm002&#x27;,1),(null,&#x27;hm003&#x27;,2),(null,&#x27;hm004&#x27;,2);</span><br><span class="line"></span><br><span class="line">SELECT user.name,orderlist.number FROM orderlist,user where orderlist.uid = user.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140742696.png" alt="image-20221114074203650"></p>
<h6 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h6><p>适用场景<br>    学生和课程。一个学生可以选择多个课程，一个课程也可以被多个学生选择。<br>建表原则<br>    &#x3D;&#x3D;需要借助第三张中间表，中间表至少包含两个列。这两个列作为中间表的外键，分别关联两张表的主键。&#x3D;&#x3D;</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140748495.png" alt="image-20221114074834422" style="zoom:67%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">	id int PRIMARY key auto_increment,</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE course(</span><br><span class="line">	id int PRIMARY key auto_increment,</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">CREATE TABLE stu_course(</span><br><span class="line">	id int PRIMARY key auto_increment,</span><br><span class="line">	sid int,</span><br><span class="line">	cid int,</span><br><span class="line">	CONSTRAINT sid_id FOREIGN key (sid) REFERENCES student(id),</span><br><span class="line">	CONSTRAINT cid_id FOREIGN key (cid) REFERENCES course(id)</span><br><span class="line">);</span><br><span class="line">INSERT into student VALUES(null,&#x27;张三&#x27;),(null,&#x27;李四&#x27;);</span><br><span class="line">INSERT into course VALUES(null,&#x27;语文&#x27;),(null,&#x27;数学&#x27;);</span><br><span class="line">INSERT into stu_course VALUES(NULL,1,1),(null,1,2),(null,2,1),(null,2,2);</span><br><span class="line"></span><br><span class="line">SELECT  course.name,student.name from student,course,stu_course WHERE stu_course.sid = student.id and stu_course.cid = course.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140813598.png" alt="image-20221114081307538"></p>
<h5 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h5><p>多表查询分类<br>    内连接查询<br>    外连接查询<br>    子查询<br>    自关联查询</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211140934423.png" alt="image-20221114093459334" style="zoom:67%;">

<h6 id="内连接查询："><a href="#内连接查询：" class="headerlink" title="内连接查询："></a>内连接查询：</h6><p>查询原理<br>    内连接查询的是两张表有交集的部分数据（有主外键关联的数据。</p>
<p>查询语法：</p>
<p>​	显式内连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 条件；</span><br></pre></td></tr></table></figure>

<p>​	隐式内连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1，表名2 WHERE 条件</span><br></pre></td></tr></table></figure>

<p>1.查询用户信息和对应的订单信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">显式内连接</span><br><span class="line">SELECT u.name,u.age,o.number FROM orderlist o INNER JOIN user_ u ON o.uid = u.id;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">隐式内连接</span><br><span class="line">SELECT u.name,u.age,o.number FROM orderlist o,user_ u WHERE o.uid = u.id;</span><br></pre></td></tr></table></figure>

<h6 id="外连接查询："><a href="#外连接查询：" class="headerlink" title="外连接查询："></a>外连接查询：</h6><p>​	左外连接查询<br>​		查询左表的全部数据，和左右两张表有交集部分的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件；</span><br></pre></td></tr></table></figure>

<p>​	右外连接查询<br>​		查询右表的全部数据，和左右两张表有交集部分的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件；</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142050262.png" alt="image-20221114205018184"></p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142050805.png" alt="image-20221114205035753"></p>
<p>查询所有用户的订单信息，这里就可以用左外连接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT u.*,o.number FROM user_ u LEFT JOIN orderlist o ON u.id = o.uid;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142056991.png" alt="image-20221114205634944"></p>
<p>查询所有的订单信息，以及所述的用户信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">	o.*,u.name,u.age </span><br><span class="line">FROM</span><br><span class="line">	orderlist o</span><br><span class="line">	RIGHT JOIN user_ u ON o.uid = u.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142102148.png" alt="image-20221114210257096"></p>
<h6 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h6><p>​	查询语句中嵌套了查询语句，我们就将嵌套的查询称为子查询。</p>
<p>&#x3D;&#x3D;查询结果为单行单列的。&#x3D;&#x3D;</p>
<p>如：查询年龄最大的用户信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name,age FROM user_ WHERE age = (SELECT MAX(age) FROM user_);</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;查询结果为多行单列的。&#x3D;&#x3D;</p>
<p>​	可以作为条件，使用运算符IN或NOT IN进行判断。</p>
<p>如：查询张三和李四的所有订单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM (SELECT </span><br><span class="line">	u.*,o.number FROM user_ u LEFT JOIN orderlist o ON u.id = o.uid) m WHERE m.&#x27;name&#x27; IN (&#x27;张三&#x27;,&#x27;李四&#x27;);</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142123301.png" alt="image-20221114212351255"></p>
<p>&#x3D;&#x3D;查询结果多行多列的。&#x3D;&#x3D;</p>
<p>​	查询的结果可以作为一张虚拟表参与查询。</p>
<p>如：查询订单表中id大于4的订单信息和所属用户信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM (SELECT * FROM orderlist o WHERE id &gt; 4) m JOIN user_ ON m.uid = user_.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142140503.png" alt="image-20221114214005454"></p>
<h6 id="自关联查询"><a href="#自关联查询" class="headerlink" title="自关联查询"></a>自关联查询</h6><p>在同一张表中数据有关联性，我们可以把这张表当成多个表来查询。</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142211483.png" alt="image-20221114221124431" style="zoom:67%;">

<p>如：查询所有的员工及其上级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT e.name , o.name FROM employee e LEFT JOIN employee o ON e.mgr = o.id  ;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142216164.png"></p>
<h5 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h5><p>UNION</p>
<p>将两条 SELECT 语句连接起来，多条语句也可两两之间使用 UNION  。使用 UNION 时，必须两条语句 字段名一样 ，类型相同或可隐式转换。UNION 会组合每条语句查询的结果，并且会消除重复行。</p>
<p>ORDER BY 排序 必须放在最后一条语句中，而且只能出现一次。会对所有行进行排序。</p>
<p>最后一句结束才有 分号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT name,age FROM a</span><br><span class="line">UNION</span><br><span class="line">SELECT name,age FROM b;</span><br></pre></td></tr></table></figure>

<p>UNION ALL</p>
<p>与 UNION 用法一样，但不会消除重复行。</p>
<h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>视图：是一种虚拟存在的数据表，这个虚拟表并不在数据库中实际存在。<br>作用：将一些较为复杂的查询语句的结果，封装到一个虚拟表中，后期再有相同需求时，直接查询该虚拟表即可。</p>
<h6 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标准语法</span><br><span class="line">CREATE VIEW view_name AS 查询语句;</span><br></pre></td></tr></table></figure>

<p>需求：查询城市信息和所属国家信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW city_country AS SELECT city.id,city.name,country.name</span><br><span class="line">FROM city,country WHERE city.cid=country.id;</span><br></pre></td></tr></table></figure>

<h6 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER VIEW view_name AS 查询语句;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：给视图增加一个字段</span><br><span class="line">ALTER VIEW city_country AS SELECT city.id,city.name,country.name,city.ip</span><br><span class="line">FROM city,country WHERE city.cid=country.id;</span><br></pre></td></tr></table></figure>

<h6 id="查询视图"><a href="#查询视图" class="headerlink" title="查询视图"></a>查询视图</h6><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM city_country;</span><br></pre></td></tr></table></figure>

<h6 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW view_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW IF EXITS view_name;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如：删除刚才创建的视图</span><br><span class="line">DROP VIEW city_country;</span><br></pre></td></tr></table></figure>





<h5 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h5><p>概念</p>
<p>​	存储过程的英文是 Stored Procedure。存储过程实际上由 SQL 语句和流控制语句共同组成。和函数一样，可以接收输入参数，也可以返回输出参数给调用者，返回计算结果。</p>
<h6 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称 ([IN /OUT/INOUT 参数名 数据类型])</span><br><span class="line">BEGIN</span><br><span class="line">    需要执行的语句</span><br><span class="line">END    </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //	将 // 作为结束符号</span><br><span class="line">CREATE PROCEDURE productpricing()	创建一个名为 productpricing 的存储过程，无参。</span><br><span class="line">BEGIN			开始符号</span><br><span class="line">	SELECT Avg(prod_price)AS priceaverage</span><br><span class="line">	FROM products;				sql 语句</span><br><span class="line">END //			结束符号</span><br><span class="line">DELIMITER ;		恢复为原来的结束符号 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CALL productpricing();   执行刚创建的存储过程并显示返回的结果。</span><br><span class="line"></span><br><span class="line">为什么这里会显示返回的结果，因为这里的 SELECT 查询出来的结果并没有存储进任何变量，所以在 CALL 时，会显示出来。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;除 \ 符号外，任何字符都可以用作结束符号  。&#x3D;&#x3D;</p>
<p>变量</p>
<p>IN：传入存储过程，可以在存储过程内部读取，但不能被修改。</p>
<p>OUT：在存储过程内部被赋值，在存储过程结束后返回给调用者。</p>
<p>INOUT：传入存储过程，可以在存储过程内部读取，也可以被修改，在存储过程结束后返回给调用者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE  IF EXISTS productpricing;     删除已存在的存储过程</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE productpricing ( </span><br><span class="line">	OUT pl DECIMAL ( 8, 2 ), </span><br><span class="line">	OUT ph DECIMAL ( 8, 2 ), </span><br><span class="line">	OUT pa DECIMAL ( 8, 2 ) ) </span><br><span class="line">BEGIN</span><br><span class="line">	SELECT</span><br><span class="line">		Min( prod_price ) INTO @pl 	INTO 是指将查询到的值存储到 pl。</span><br><span class="line">	FROM</span><br><span class="line">		products;</span><br><span class="line">	SELECT</span><br><span class="line">		Max( prod_price ) INTO @ph 	将查询到的值存储到 ph。</span><br><span class="line">	FROM</span><br><span class="line">		products;</span><br><span class="line">	SELECT</span><br><span class="line">		Avg( prod_price ) INTO @pa 	将查询到的值存储到 pa。</span><br><span class="line">	FROM</span><br><span class="line">		products;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">CALL productpricing ( @pl, @pricehigh, @priceaverage );</span><br><span class="line">这里相当于吧 ph 赋值给 pricehigh，pa 赋值给 priceaverage。</span><br><span class="line">为什么这里不显示数值，因为上面的语句是 把 SELECT 的结果存储进 （INTO）后面的变量，所以不会显示返回的结果。返回的结果需要使用 SELECT 查询。</span><br><span class="line">SELECT @priceaverage;</span><br><span class="line"></span><br><span class="line">在 CALL 和 SELECT 时，变量必须用 @ 表示。</span><br></pre></td></tr></table></figure>

<p>上面的例子 参数都是 OUT。下面举例参数有IN。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入订单号，显示订单总金额。</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,</span><br><span class="line">	OUT ototal DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">	SELECT Sum</span><br><span class="line">		(item_price*quantity)</span><br><span class="line">	FROM </span><br><span class="line">		orderitems</span><br><span class="line">	WHERE </span><br><span class="line">		order_num onumber</span><br><span class="line">	INTO ototal;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">CALL(20005,@ototal);</span><br><span class="line">SELECT(@ototal); 		</span><br><span class="line">因为在 CALL 执行的时候已经将 查询结果存储进了 ototal 变量，所以需要 SELECT 才能显示出来。</span><br></pre></td></tr></table></figure>

<p>局部变量、注释、流程控制语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">	IN onumber INT,  订单号</span><br><span class="line">	IN taxable BOOLEAN,		是否缴税。缴税为1 ，未缴税为 0</span><br><span class="line">	OUT ototal DECIMAL(8,2)</span><br><span class="line">)COMMENT &#x27;Obtain order total,optionally adding tax&#x27;</span><br><span class="line">BEGIN</span><br><span class="line">	--Declare variable for total</span><br><span class="line">	DECLARE total DECIMAL(8,2);		DECLARE 定义局部变量</span><br><span class="line">	--Declare tax percentage</span><br><span class="line">	DECLARE taxrate INT DEFAULT 6;	taxrate税率，设置默认 6%</span><br><span class="line">	--Get the order total</span><br><span class="line">	SELECT </span><br><span class="line">		Sum(item_price*quantity)</span><br><span class="line">	FROM orderitems</span><br><span class="line">	WHERE order_num = onumber</span><br><span class="line">	INTO total;</span><br><span class="line">	--Is this taxable?</span><br><span class="line">	IF taxable THEN</span><br><span class="line">	--Yes,so add taxrate to the total</span><br><span class="line">	SELECT total+(total/100*taxrate)INTO total;</span><br><span class="line">	END IF;		结束 IF 语句 </span><br><span class="line">	--And finally,save to out variable</span><br><span class="line">	SELECT total INTO ototal;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>



<h6 id="执行存储过程"><a href="#执行存储过程" class="headerlink" title="执行存储过程"></a>执行存储过程</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储名称();   </span><br></pre></td></tr></table></figure>

<p>CALL 执行刚创建的存储过程并显示返回的结果。</p>
<h6 id="显示存储结果"><a href="#显示存储结果" class="headerlink" title="显示存储结果"></a>显示存储结果</h6><p>需要用 SELECT  @参数 来显示值。具体什么时候用 SELECT 看上面分析。</p>
<p>显示存储过程的创建语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE procedure_name;</span><br></pre></td></tr></table></figure>

<p>显示存储过程的详细属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS  显示所有的存储过程</span><br><span class="line"></span><br><span class="line">SHOW PROCEDURE STATUS LIKE &#x27;&#x27; 显示过滤后的存储过程。</span><br></pre></td></tr></table></figure>



<h6 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER PROCEDURE</span><br></pre></td></tr></table></figure>



<h6 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE procedure_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE IF EXITS procedure_name;</span><br></pre></td></tr></table></figure>



<h5 id="SELECT-小结"><a href="#SELECT-小结" class="headerlink" title="SELECT 小结"></a>SELECT 小结</h5><p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202307041854319.jpeg" alt="img"></p>
<h5 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h5><p>IF 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF</span><br><span class="line">	语句</span><br><span class="line">	THEN </span><br><span class="line">		语句</span><br><span class="line">	ESLE IF </span><br><span class="line">		语句</span><br><span class="line">	THEN </span><br><span class="line">		语句</span><br><span class="line">	ELSE</span><br><span class="line">		语句</span><br><span class="line">END IF;		结束 IF 语句</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<p>CASE 语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">	WHEN when_value1 THEN a;	当条件 case_value 等于 when_value1 时 执行 a 语句，</span><br><span class="line">	[WHEN when_value2 THEN b;]	当等于 when_value2 时，执行 b 语句，</span><br><span class="line">	[ELSE c;]		都不等于，执行 c 语句。</span><br><span class="line">END CASE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">CASE age</span><br><span class="line">    WHEN 20 THEN SELECT * FROM products;  </span><br><span class="line">    ELSE  SELECT name FROM products;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE </span><br><span class="line">	WHEN search_condition1 THEN a;		当 search_condition1 条件成立时 ，执行 a 语句，</span><br><span class="line">	[WHEN search_condition2 THEN b;]	当 search_condition2 条件成立时 ，执行 b 语句，</span><br><span class="line">	[ELSE c;]		都不成立，执行c 语句。</span><br><span class="line">END CASE;		结束 CASE 语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">举例：</span><br><span class="line">CASE </span><br><span class="line">	WHEN age = 20 THEN SELECT * FROM products; </span><br><span class="line">	WHEN age = 30 SELECT address FROM products;</span><br><span class="line">	ELSE SELECT name FROM products;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>



<h5 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h5><h6 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h6><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202307041901385.png" alt="img" style="zoom: 50%;">

<p>&#x3D;&#x3D;MySQL 中，不支持（!&gt;）（!&lt;）等。&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BETWEEN语句   左包含，右包含</span><br><span class="line">SQL：SELECT name, hp_max FROM heros WHERE hp_max BETWEEN 5399 AND 6811</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IS NULL空值检查。IS NOT NULL非空</span><br><span class="line">SQL：SELECT name, hp_max FROM heros WHERE hp_max IS NULL</span><br><span class="line">运行结果为空，说明表中的hp_max字段没有存在空值的数据行。</span><br></pre></td></tr></table></figure>



<h6 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h6><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202307041904739.png" alt="img" style="zoom:50%;">



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AND语句</span><br><span class="line">SQL：SELECT name, hp_max, mp_max FROM heros WHERE hp_max &gt; 6000 AND mp_max &gt; 1700 ORDER BY (hp_max+mp_max) DESC</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OR和AND语句</span><br><span class="line">SQL：SELECT name, hp_max, mp_max FROM heros WHERE (hp_max+mp_max) &gt; 8000 OR hp_max &gt; 6000 AND mp_max &gt; 1700 ORDER BY (hp_max+mp_max) DESC</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;当 WHERE 子句中同时存在 OR 和 AND 的时候，AND 执行的优先级会更高，也就是说 SQL 会优先处理 AND 操作符，然后再处理 OR 操作符。&#x3D;&#x3D;</p>
<h5 id="使用通配符进行过滤"><a href="#使用通配符进行过滤" class="headerlink" title="使用通配符进行过滤"></a>使用通配符进行过滤</h5><p>LIKE 操作符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匹配任意字符   %</span><br><span class="line">SQL：SELECT name FROM heros WHERE name LIKE &#x27;%太%&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">匹配单个字符   _</span><br><span class="line">SQL：SELECT name FROM heros WHERE name LIKE &#x27;_%太%&#x27;</span><br></pre></td></tr></table></figure>



<h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><h6 id="算术函数"><a href="#算术函数" class="headerlink" title="算术函数"></a>算术函数</h6><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202307041914015.png" alt="img" style="zoom: 50%;">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ABS(-2)，运行结果为 2。</span><br><span class="line">SELECT MOD(101,3)，运行结果 2。</span><br><span class="line">SELECT ROUND(37.25,1)，运行结果 37.3。</span><br></pre></td></tr></table></figure>



<h6 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h6><table>
<thead>
<tr>
<th align="left">函数名</th>
<th align="left">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CONCAT()</td>
<td align="left">将多个字符串拼接起来</td>
</tr>
<tr>
<td align="left">LENGTH()</td>
<td align="left">计算字段的长度，一个汉字算三个字符，一个数字或字母算一个字符</td>
</tr>
<tr>
<td align="left">CHAR_LENGTH()</td>
<td align="left">计算字段的长度，汉字、数字、字母都算一个字符</td>
</tr>
<tr>
<td align="left">LOWER()</td>
<td align="left">将字符串中的字符转化为小写</td>
</tr>
<tr>
<td align="left">UPPER()</td>
<td align="left">将字符串中的字符转化为大写</td>
</tr>
<tr>
<td align="left">REPLACE()</td>
<td align="left">替换函数，有3个参数，分别为：要替换的表达式或字段名、想要查找的被替换字符串、替换成哪个字符串</td>
</tr>
<tr>
<td align="left">SUBSTRING()</td>
<td align="left">截取字符串，有3个参数，分别为：待截取的表达式或字段名、开始截取的位置、想要截取的字符串长度</td>
</tr>
<tr>
<td align="left">TRIM()</td>
<td align="left">去空格函数 ,LTRIM 去掉字符串左边的空格。RTRIM 去掉字符串右边 的空格。TRIM 去掉字符串两边 的空格。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&#x27;abc&#x27;, 123)，运行结果为 abc123。</span><br><span class="line">SELECT LENGTH(&#x27;你好&#x27;)，运行结果为 6。</span><br><span class="line">SELECT CHAR_LENGTH(&#x27;你好&#x27;)，运行结果为 2。</span><br><span class="line">SELECT LOWER(&#x27;ABC&#x27;)，运行结果为 abc。</span><br><span class="line">SELECT UPPER(&#x27;abc&#x27;)，运行结果 ABC。</span><br><span class="line">SELECT REPLACE(&#x27;fabcd&#x27;, &#x27;abc&#x27;, 123)，运行结果为 f123d。</span><br><span class="line">SELECT SUBSTRING(&#x27;fabcd&#x27;, 1,3)，运行结果为 fab。</span><br><span class="line">SELECT CONCAT(RTRIM(&#x27;name&#x27;),&#x27;(&#x27;,RTRIM(&#x27;age&#x27;),&#x27;)&#x27;)</span><br></pre></td></tr></table></figure>





<h6 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h6><table>
<thead>
<tr>
<th align="center">函数名</th>
<th align="center">定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CURRENT_DATE()或 CURDATE()</td>
<td align="center">系统当前日期，2024-04-06</td>
</tr>
<tr>
<td align="center">CURRENT_TIME()</td>
<td align="center">系统当前时间，没有具体的日期，23:22:22</td>
</tr>
<tr>
<td align="center">CURRENT_TIMESTAMP()</td>
<td align="center">系统当前时间，包括具体的日期+时间，2024-04-06 23:22:22</td>
</tr>
<tr>
<td align="center">EXTRACT()</td>
<td align="center">抽取具体的年、月、日</td>
</tr>
<tr>
<td align="center">DATE()</td>
<td align="center">返回时间的日期部分</td>
</tr>
<tr>
<td align="center">YEAR()</td>
<td align="center">返回时间的年份部分</td>
</tr>
<tr>
<td align="center">MONTH()</td>
<td align="center">返回时间的月份部分</td>
</tr>
<tr>
<td align="center">DAY()</td>
<td align="center">返回时间的天数部分</td>
</tr>
<tr>
<td align="center">HOUR()</td>
<td align="center">返回时间的小时部分</td>
</tr>
<tr>
<td align="center">MINUTE()</td>
<td align="center">返回时间的分钟部分</td>
</tr>
<tr>
<td align="center">SECOND()</td>
<td align="center">返回时间的秒部分</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CURRENT_DATE()，运行结果为 2019-04-03。</span><br><span class="line">SELECT CURRENT_TIME()，运行结果为 21:26:34。</span><br><span class="line">SELECT CURRENT_TIMESTAMP()，运行结果为 2019-04-03 21:26:34。</span><br><span class="line">SELECT EXTRACT(YEAR FROM &#x27;2019-04-03&#x27;)，运行结果为 2019。</span><br><span class="line">SELECT DATE(&#x27;2019-04-01 12:00:05&#x27;)，运行结果为 2019-04-01。</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;这里需要注意的是，DATE 日期格式必须是 yyyy-mm-dd 的形式。如果要进行日期比较，就要使用 DATE 函数，不要直接使用日期与字符串进行比较，&#x3D;&#x3D;</p>
<h6 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h6><p>CAST()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAST (a AS bType)将 a 转换为 b 类型</span><br></pre></td></tr></table></figure>

<p>整数 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SIGNED 和 UNSIGNED</span><br></pre></td></tr></table></figure>

<p>字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHAR</span><br></pre></td></tr></table></figure>

<p>小数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECIMAL(总位数, 小数点后位数)</span><br><span class="line">计算时会四舍五入</span><br></pre></td></tr></table></figure>

<p>日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATE</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CAST(&#x27;123&#x27; AS SIGNED);</span><br><span class="line">CAST (123 AS CHAR) 将 123 转换为 字符串</span><br><span class="line">CAST(&#x27;2023-10-23&#x27; AS CHAR);  -- 结果：&#x27;2023-10-23&#x27;</span><br><span class="line">CAST(&#x27;2023-10-23&#x27; AS DATE);  -- 结果：&#x27;2023-10-23&#x27;</span><br><span class="line">SELECT CAST(123.124 AS DECIMAL(10,2));  -- 结果：123.12</span><br><span class="line">SELECT CAST(123.126 AS DECIMAL(10,2));  -- 结果：123.13</span><br></pre></td></tr></table></figure>



<p>CONVERT()</p>
<p>CAST 函数在转换数据类型的时候，不会四舍五入，如果原数值有小数，那么转换为整数类型的时候就会报错。不过你可以指定转化的小数类型，在 MySQL 和 SQL Server 中，你可以用DECIMAL(a,b)来指定，其中 a 代表整数部分和小数部分加起来最大的位数，b 代表小数位数，比如DECIMAL(8,2)代表的是精度为 8 位（整数加小数位数最多为 8 位），小数位数为 2 位的数据类型。所以SELECT CAST(123.123 AS DECIMAL(8,2))的转换结果为 123.12。</p>
<p>别名 </p>
<p>AS</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT student_name AS name FROM student stu ;</span><br></pre></td></tr></table></figure>



<h5 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h5><p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。  </p>
<h6 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h6><p>游标一般在存储过程中使用。使用 declare 定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">	DECLARE cursor_name CURSOR</span><br><span class="line">	FOR</span><br><span class="line">    SQL 语句;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">	BEGIN</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h6 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h6><p>在结束游标使用时，必须关闭游标。  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN cursor_name;</span><br><span class="line">CLOSE cursor_name;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE processorders(</span><br><span class="line">BEGIN</span><br><span class="line">	--Declare the cursor</span><br><span class="line">	DECLARE ordernumbers CURSOR</span><br><span class="line">	FOR</span><br><span class="line">	SELECT order_num FROM orders;</span><br><span class="line">	--Open the cursor</span><br><span class="line">	OPEN ordernumbers;</span><br><span class="line">	--Close the cursor</span><br><span class="line">	CLOSE ordernumbers;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h6 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h6><p>FETCH 语句，检索数据  </p>
<h5 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h5><p>想要某条语句（或某些语句）在事件发生时自动执行，需要使用触发器。</p>
<p>例如：</p>
<p>1、每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否为大写；</p>
<p>2、每当订购一个产品时，都从库存数量中减去订购的数量；</p>
<p>3、无论何时删除一行，都在某个存档表中保留一个副本。</p>
<h6 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h6><p>需要的四个条件：</p>
<p>1、唯一的触发器名；</p>
<p>2、触发器关联的表；</p>
<p>3、触发器应该响应的活动（ 触发器只支持触发 DELETE、 INSERT或UPDATE 语句）；</p>
<p>4、触发器何时执行（处理之前 BEFORE 或之后 AFTER）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW </span><br><span class="line">SELECT </span><br><span class="line">	&#x27;Product added&#x27; INTO @abc;</span><br><span class="line">创建一个名为newproduct 的触发器，在 products 表中每添加一行执行这条语句（把 Product added 这句话赋值给变量 abc ）。</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;MYSQL5以后，不允许触发器返回任何结果，因此使用into@变量名，将结果赋值到变量中，用select调用即可。&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @abc</span><br></pre></td></tr></table></figure>

<p>以下为输出结果。</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240409222505561.png" alt="image-20240409222505561"></p>
<h6 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TRIGGER 触发器名;</span><br></pre></td></tr></table></figure>





<h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>事务：一条或多条SQL语句组成一个执行单元，其特点是这个单元要么同时成功要么同时失败。</p>
<p>事务常用于 INSERT、UPDATE、DELATE 语句。</p>
<h6 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br></pre></td></tr></table></figure>

<h6 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h6><p>回滚必须在 提交之前，提交成功之后不能再 ROLLBACK。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM test;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM test;</span><br><span class="line">SELECT * FROM test;</span><br><span class="line">ROLLBACK;</span><br><span class="line">SELECT * FROM test;</span><br></pre></td></tr></table></figure>

<h6 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h6><p>默认情况下，MySQL 是在自动提交模式下运行的。（隐式提交）</p>
<p>在事务处理块中需要明确的提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM orderitems WHERE order_num = 20010;</span><br><span class="line">DELETE FROM orders WHERE order_num = 20010;</span><br><span class="line">可以在这里写判断语句，</span><br><span class="line">IF ....</span><br><span class="line">	THEN</span><br><span class="line">	ROLLBACK;</span><br><span class="line">ELSE</span><br><span class="line">	COMMIT;</span><br><span class="line">END IF;</span><br><span class="line">因为涉及更新两个数据库表orders和orderItems，所以使用事务处理块来保证订单不被部分删除。</span><br><span class="line">根据 if 语句判断是否回滚。</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;事务提交之后将不能 ROLLBACK 方式回滚。但是可以使用 二进制日志文件或者备份来回滚。&#x3D;&#x3D;</p>
<h6 id="事务的提交方式："><a href="#事务的提交方式：" class="headerlink" title="事务的提交方式："></a>事务的提交方式：</h6><p>自动提交（默认）</p>
<p>​	默认情况下，MySQL 是在自动提交模式下运行的。（隐式提交）</p>
<p>手动提交</p>
<p>​	在事务处理块中需要明确的提交，如多个删除语句。</p>
<h6 id="事务的四大特征（ACID）"><a href="#事务的四大特征（ACID）" class="headerlink" title="事务的四大特征（ACID）"></a>事务的四大特征（ACID）</h6><p>原子性(Atomicity)<br>    原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。<br>    因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。<br>一致性(Consistency)<br>    一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态。<br>    也就是说一个事务执行之前和执行之后都必须改处于一致性状态。<br>隔离性(isolcation)	<br>    隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务。<br>    不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>持久性(durability)<br>    持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的。<br>    即便是在数据库系统遇到故的情况下也不会丢失提交事务的操作。</p>
<h6 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h6><p>事务的隔离级别<br>    多个客户端操作时，各个客户端的事务之间应该是隔离的，相西独立的，不受影响的。<br>    而如果多个事务操同一批数据时，就会产生不同的问题，我们需要设置不同的隔离级别来解决这些问题。</p>
<p>隔离级别的分类</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142312993.png" alt="image-20221114231230916" style="zoom: 67%;">

<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211142347645.png" alt="image-20221114234740556" style="zoom: 67%;">



<p>&#x3D;&#x3D;mysql的默认隔离级别是：repeatable read （可重复读）&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;串行化(serializable)隔离级别相当于把整张表锁起来，在该事务未提交时，别的事务也不能操作该数据。&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;隔离级别从小到大安全性越来越高，串行化(serializable)隔离级别最高，但是效率越来越低，所以不建议修改数据库默认的隔离级别。&#x3D;&#x3D;</p>
<p>查询隔离级别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT@0 TX ISOLATION;</span><br></pre></td></tr></table></figure>

<p>修改隔离级别：（修改后需要重新连接数据库）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL 级别字符串;</span><br></pre></td></tr></table></figure>

<p>如：将隔离级别修改为：读已提交。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br></pre></td></tr></table></figure>



<p>&#x3D;&#x3D;脏读的问题解决：&#x3D;&#x3D;</p>
<p>​	脏读是在 读未提交(read uncommitted)隔离级别产生的。</p>
<p>​	解决方式，是将隔离级别修改为：(read committed)读已提交。</p>
<p>&#x3D;&#x3D;不可重复读的问题解决：&#x3D;&#x3D;</p>
<p>​	不可重复读是在 读已提交(read committed)隔离级别产生的。</p>
<p>​	解决方式，是将隔离级别修改为：(repeatable read)可重复读。</p>
<p>&#x3D;&#x3D;幻读的问题解决：&#x3D;&#x3D;</p>
<p>​	幻读是在 可重复度(repeadtable read)隔离级别产生的。</p>
<p>​	解决方式，是将隔离级别修改为：(serializable)串行化。</p>
<h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><p>MySQL支持的存储引擎有很多，常用的有三种：InnoDB、MyISAM、MEMORY。<br>特性对比</p>
<p>​	InnoDB存储引擎：支持事务和外键操作，支持并发控制，占用磁盘空间大。(是mySQL5.5版本后默认的存储引擎)</p>
<p>​	MyISAM存储引擎：访问快，不支持事务和外键操作。<br>​	MEMORY存储擎：内存存储，速度快，不安全。适合小量快速访问的数据。</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211150135854.png" alt="image-20221115013533759" style="zoom:67%;">

<h6 id="存储引擎的查询操作"><a href="#存储引擎的查询操作" class="headerlink" title="存储引擎的查询操作"></a>存储引擎的查询操作</h6><p>查询数据库支持的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<p>查询某个数据库中所有数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称;</span><br></pre></td></tr></table></figure>

<p>查询某个数据库中某个数据表的存储都引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW TABLE STATUS FROM 数据库名称 WHERE NAME=&#x27;数据表名称&#x27;;</span><br></pre></td></tr></table></figure>

<h6 id="存储引擎的创建操作"><a href="#存储引擎的创建操作" class="headerlink" title="存储引擎的创建操作"></a>存储引擎的创建操作</h6><p>创建数据表，指定存储都引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">	列名，数据类型</span><br><span class="line">)ENGINE=引擎名称</span><br></pre></td></tr></table></figure>

<h6 id="存储引擎的修改操作"><a href="#存储引擎的修改操作" class="headerlink" title="存储引擎的修改操作"></a>存储引擎的修改操作</h6><p>修改数据表的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名 ENGINE=引擎名称;</span><br></pre></td></tr></table></figure>



<h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><h6 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h6><p>按照功能分类<br>    普通索引：最基本的索引，没有任何限制。<br>    唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值组合必须唯一。<br>    主键索引：一种特殊的唯一索引，不允许有空值。在建表时有主键列同时创建主键索引。<br>    联合索引：顾名思义，就是将单列索引进行组合。<br>    外键索引：只有lnnoDB引擎支持外键索引，用来保证数据的一致性、完整性和实现级联操作。<br>    全文索引：快速匹配全部文档的方式。InnoDB引擎5.6版本后才支特全文索引。MEMORY引擎不支持。<br>按照结构分类<br>    BTree索引：MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎默认的索类型，底层基于B+Tree数据结构。<br>    Hash索引：MySQL中MEMORY存储引擎默认支持的索引类型。</p>
<h6 id="索引的操作"><a href="#索引的操作" class="headerlink" title="索引的操作"></a>索引的操作</h6><p>创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE[UNIQUE | FULLTEXT] INDEX 索引名称</span><br><span class="line">[USING 索引类型]</span><br><span class="line">ON 表名(列名...);</span><br></pre></td></tr></table></figure>

<p>查看索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM 表名;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">	id int PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	name VARCHAR(10),</span><br><span class="line">	age int,</span><br><span class="line">	score int</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">INSERT INTO student VALUES</span><br><span class="line">(NULL,&#x27;张三&#x27;,23,98),(NULL,&#x27;李四&#x27;,24,95),</span><br><span class="line">(NULL,&#x27;王五&#x27;,25,96),(NULL,&#x27;赵六&#x27;,26,94),(NULL,&#x27;周七&#x27;,27,99);</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211151722882.png" alt="image-20221115172203822"></p>
<p>为name字段创建普通索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE INDEX idx_name ON student(name);</span><br></pre></td></tr></table></figure>

<p>为age字段创建唯一索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX idx_age on student(age);</span><br></pre></td></tr></table></figure>

<p>查看索引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW INDEX FROM student;</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202211151725837.png" alt="image-20221115172540781"></p>
<p>查询结果有三条数据，因为在创建数据表的时候，给id 设置了主键约束，主键约束会自动创建主键索引。</p>
<p>主键约束和外键约束，会创建主键索引、外键索引。</p>
<p>删除索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP INDEX 索引名称 ON 表名；</span><br></pre></td></tr></table></figure>



<h6 id="索引的原理"><a href="#索引的原理" class="headerlink" title="索引的原理"></a>索引的原理</h6><p>BTree索l类型是基于B+Tree数据结构的，而B+Tree数据结构又是BTree数据结构的变种。通常使用在数据库和操作系统中的文件系统，特点是能够保持数据稳定有序。</p>
<p>BTree</p>
<p>​	每个节点中不仅包含key值，还有数据。会增加查询数据时磁盘的IO次数。</p>
<p>B+Tree<br>    非叶子节点只存储key值。<br>    所有数据存储在叶子节点。<br>    所有叶子节点之形成有序链表。</p>
<p>创建索引遵循的原则：</p>
<p>​	对查询频次较高，且数据量比较大的表建立索引。<br>​	使用唯一索引，区分度越高，使用索引的效率越高。<br>​	索引字段的选择，最佳候选列应当从where子句的条件中提取。<br>​	索引虽然可以有效的提升查询数据的效率，但并不是多多益善。</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202306161514152.png" alt="image-20230616151423047" style="zoom: 50%;">



<p>B+Tree与B-Tree之间有哪些区别？</p>
<p>区别1： B+Tree节点关键字搜索采用左闭合区间</p>
<p>区别2： B+Tree非叶子节点不保存数据相关信息，只保存关键字和子节点的引用</p>
<p>区别3： B+Tree节点关键字对应的数据只保存在叶子节点中</p>
<p>区别4： B+Tree叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系</p>
<p>MySQL数据库为何最终选择用B+Tree?</p>
<p>原因1： B+Tree是B-Tree的变种，B-Tree能解决的问题，B+Tree也能够解决，而且可以有效降低树的高度，减少磁盘IO次数，增大节点存储数据量。</p>
<p>原因2： B+Tree扫库和扫表能力更强。如果我们要根据索引去进行数据表的扫描，对B-Tree进行扫描，需要把整棵树遍历一遍，而B+Tree只需要遍历他的所有叶子节点即可（叶子节点之间有引用）。</p>
<p>原因3： B+Tree磁盘读写能力更强。他的根节点和支节点不保存数据区，所以根节点和支节点同样大小的情况下，保存的关键字要比B-Tree多。而叶子节点不保存子节点引用，能用于保存更多的关键字和数据。所以，B+Tree读写一次，磁盘加载的关键字比B-Tree更多。</p>
<p>原因4： B+Tree排序能力更强。上面的图中可以看出，B+Tree天然具有排序功能。</p>
<p>原因5： B+Tree查询性能稳定。B+Tree数据只保存在叶子节点，每次查询数据，查询IO次数一定是稳定的。</p>
<h6 id="索引的设计原则："><a href="#索引的设计原则：" class="headerlink" title="索引的设计原则："></a>索引的设计原则：</h6><p>最左匹配原则（适用组合索引）<br>例如：为user表中的name、address、phone列添加组合索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE user ADD INDEX idx three (name,address,phone);</span><br></pre></td></tr></table></figure>

<p>此时，组合索引idx three实际建立了(name)、(name,address)、(name,address,phone)三个索引<br>下面的三个SQL语句都可以命中索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT*FROM user WHERE address=&#x27;北京&#x27;AND phone=&#x27;12345&#x27;AND name=&#x27;张三，含1141451正在</span><br><span class="line">SELECT*FROM user WHERE name=&#x27;张三&#x27;AND address=&#x27;H北京&#x27;；</span><br><span class="line">SELECT*FROM user WHERE name=&#x27;张三&#x27;；</span><br></pre></td></tr></table></figure>

<p>这三条SQL语句在检索时分别会使用以下索引进行数据匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(name,address,phone)</span><br><span class="line">(name,address)</span><br><span class="line">(name)</span><br></pre></td></tr></table></figure>

<p>索引字段出现的顺序可以是任意的，MySQL优化器会帮我们自动的调整where条件中的顺序</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL安装配置文档</title>
    <url>/MySQL%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<blockquote>
<p><strong>安装环境:Win10 64位</strong><br><strong>软件版本:MySQL 5.7.24 解压版</strong></p>
</blockquote>
<h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p>点开下面的链接：<br><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p>
<h2 id="二、linux-安装"><a href="#二、linux-安装" class="headerlink" title="二、linux 安装"></a>二、linux 安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、通过secureCRT.工具连接Linux系统</span><br><span class="line"></span><br><span class="line">2、上传mysq的安装包</span><br><span class="line">	alt+p，然后 put d:/develop/mysql-5.7.18-1.e17.x86_64.rpm-bundle.tar</span><br><span class="line">	</span><br><span class="line">3、解压mysql的安装包</span><br><span class="line">	mkdir mysql </span><br><span class="line">	tar -xvf mysql-5.7.18-1.el8.x86_64.rpm-bundle.tar -C mysql/</span><br><span class="line">	</span><br><span class="line">4、安装客户端</span><br><span class="line">    cd mysql/</span><br><span class="line">	rpm -ivh mysql-community-client-5.7.18-1.e17.x86_64.rpm --force --nodeps</span><br><span class="line">	</span><br><span class="line">5、安装服务端</span><br><span class="line">	rpm -ivh mysql-community-server-5.7.18-1.e17.x86_64.rpm --force --nodeps</span><br><span class="line">	</span><br><span class="line">6、修改mysql默认字符集</span><br><span class="line">	vi /etc/my.cnf</span><br><span class="line">	添加如下内容：</span><br><span class="line">	[mysqld]</span><br><span class="line">	character-set-server=utf8</span><br><span class="line">	collation-server=utf8_general_ci</span><br><span class="line">	--在文件最下方添加</span><br><span class="line">	[client]</span><br><span class="line">	default-character-set=utf8</span><br><span class="line"></span><br><span class="line">7、启动mysql服务</span><br><span class="line">	service mysqld start</span><br><span class="line">	</span><br><span class="line">8、登录mysql</span><br><span class="line">	mysql -u root -p 敲回车，输入密码</span><br><span class="line">	初始密码查看：cat /var/log/mysqld.log</span><br><span class="line">		在root@localhost:   后面的就是初始密码</span><br><span class="line">		</span><br><span class="line">9、修改mysql登录密码</span><br><span class="line">	set global validate_password_policy=0;</span><br><span class="line">	set global validate_password_length=1;</span><br><span class="line">	set password=password(&#x27;密码&#x27;);    //这里密码设置为***    set password=password(&#x27;***&#x27;);</span><br><span class="line">	</span><br><span class="line">10、授予远程连接权限</span><br><span class="line">	//授权</span><br><span class="line">	grant all privileges on *.* to &#x27;root&#x27; @&#x27;%&#x27; identified by &#x27;***&#x27;;</span><br><span class="line">	//刷新</span><br><span class="line">	flush privileges;</span><br><span class="line">	</span><br><span class="line">11、退出mysql界面，关闭Linux系统防火墙</span><br><span class="line">	systemctl stop firewalld</span><br><span class="line">	</span><br><span class="line">12、重启mysql服务</span><br><span class="line">	service mysqld restart</span><br><span class="line">	</span><br><span class="line">13、使用SQLYog工具连接mysql</span><br></pre></td></tr></table></figure>

<p>”&#x2F;“是根目录，”~“是home目录。</p>
<p>&#x2F;是指根目录：就是所有目录最顶层的目录</p>
<p>~是当前用户的家目录：如果是root用户就是&#x2F;root&#x2F;目录， 如果是其他用户就是&#x2F;home&#x2F;下用户名命名的用户 </p>
<h2 id="三、windows安装"><a href="#三、windows安装" class="headerlink" title="三、windows安装"></a>三、windows安装</h2><h3 id="1、解压mysql压缩包"><a href="#1、解压mysql压缩包" class="headerlink" title="1、解压mysql压缩包"></a>1、解压mysql压缩包</h3><h3 id="2、添加环境变量"><a href="#2、添加环境变量" class="headerlink" title="2、添加环境变量"></a>2、添加环境变量</h3><blockquote>
<p>环境变量里面有很多选项，这里我们只用到<code>Path</code>这个参数。为什么在初始化的开始要添加环境变量呢？<br>在黑框(即CMD)中输入一个可执行程序的名字，Windows会先在环境变量中的<code>Path</code>所指的路径中寻找一遍，如果找到了就直接执行，没找到就在当前工作目录找，如果还没找到，就报错。我们添加环境变量的目的就是能够在任意一个黑框直接调用MySQL中的相关程序而不用总是修改工作目录，大大简化了操作。</p>
</blockquote>
<p>右键<code>此电脑</code>→<code>属性</code>，点击<code>高级系统设置</code></p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216257.png" alt="img"></p>
<p>点击<code>环境变量</code></p>
<p>在<code>系统变量</code>中新建MYSQL_HOME</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216731.png" alt="image-20201109140222488"></p>
<p>在<code>系统变量</code>中找到并<strong>双击</strong><code>Path</code></p>
<p>点击<code>新建</code></p>
<p>最后点击确定。</p>
<p><strong>如何验证是否添加成功？</strong></p>
<p>右键开始菜单(就是屏幕左下角)，选择<code>命令提示符(管理员)</code>，打开黑框，敲入<code>mysql</code>，回车。<br>如果提示<code>Can&#39;t connect to MySQL server on &#39;localhost&#39;</code>则证明添加成功；<br>如果提示<code>mysql不是内部或外部命令，也不是可运行的程序或批处理文件</code>则表示添加添加失败，请重新检查步骤并重试。</p>
<h3 id="3、新建配置文件"><a href="#3、新建配置文件" class="headerlink" title="3、新建配置文件"></a>3、新建配置文件</h3><p>新建一个文本文件，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="attr">default-character-set</span>=<span class="string">utf8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">character-set-server</span>=<span class="string">utf8</span></span><br><span class="line"><span class="attr">default-storage-engine</span>=<span class="string">INNODB</span></span><br><span class="line"><span class="attr">sql_mode</span>=<span class="string">STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span></span><br></pre></td></tr></table></figure>

<p>把上面的文本文件另存为，在保存类型里选<code>所有文件 (*.*)</code>，文件名叫<code>my.ini</code>，存放的路径为MySQL的<code>根目录</code>(例如我的是<code>D:\software\mysql-5.7.24-winx64</code>,根据自己的MySQL目录位置修改)。</p>
<h3 id="4、初始化MySQL"><a href="#4、初始化MySQL" class="headerlink" title="4、初始化MySQL"></a>4、初始化MySQL</h3><p>在刚才的黑框中敲入<code>mysqld --initialize-insecure</code>，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216706.png" alt="image-20201109140955772"></p>
<p>tips：如果出现如下错误</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216910.png" alt="image-20201109135848054"></p>
<p>是由于权限不足导致的，去<code>C:\Windows\System32</code> 下以管理员方式运行 cmd.exe</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216508.png" alt="image-20201109140001186"></p>
<h3 id="5、注册MySQL服务"><a href="#5、注册MySQL服务" class="headerlink" title="5、注册MySQL服务"></a>5、注册MySQL服务</h3><p>在黑框里敲入<code>mysqld -install</code>，回车。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld -install</span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216710.png" alt="image-20201109141325810"></p>
<p>现在你的计算机上已经安装好了MySQL服务了。</p>
<h3 id="6、-启动MySQL服务"><a href="#6、-启动MySQL服务" class="headerlink" title="6、 启动MySQL服务"></a>6、 启动MySQL服务</h3><p>在黑框里敲入<code>net start mysql</code>，回车。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">net start mysql  <span class="comment">// 启动mysql服务</span></span><br><span class="line">    </span><br><span class="line">net stop mysql  <span class="comment">// 停止mysql服务</span></span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216751.png" alt="img"></p>
<h3 id="7、修改默认账户密码"><a href="#7、修改默认账户密码" class="headerlink" title="7、修改默认账户密码"></a>7、修改默认账户密码</h3><p>在黑框里敲入<code>mysqladmin -u root password 1234</code>，这里的<code>1234</code>就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root password 1234</span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216797.png" alt="img"></p>
<p><strong>至此，MySQL 5.7 解压版安装完毕！</strong></p>
<hr>
<h2 id="四、登录MySQL"><a href="#四、登录MySQL" class="headerlink" title="四、登录MySQL"></a>四、登录MySQL</h2><p>右键开始菜单，选择<code>命令提示符</code>，打开黑框。<br>在黑框中输入，<code>mysql -uroot -p1234</code>，回车，出现下图且左下角为<code>mysql&gt;</code>，则登录成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p1234</span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216916.png" alt="img"></p>
<p><strong>到这里你就可以开始你的MySQL之旅了！</strong></p>
<p>退出mysql：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>登陆参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306)</span><br><span class="line">mysql -uroot -p1234 -h127.0.0.1 -p3306</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="五、卸载MySQL"><a href="#五、卸载MySQL" class="headerlink" title="五、卸载MySQL"></a>五、卸载MySQL</h2><p>如果你想卸载MySQL，也很简单。</p>
<p>右键开始菜单，选择<code>命令提示符(管理员)</code>，打开黑框。</p>
<ol>
<li>敲入<code>net stop mysql</code>，回车。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216953.png" alt="img"></p>
<ol start="2">
<li>再敲入<code>mysqld -remove mysql</code>，回车。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqld -remove mysql</span><br></pre></td></tr></table></figure>



<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403172216027.png" alt="img"></p>
<ol start="3">
<li>最后删除MySQL目录及相关的环境变量。</li>
</ol>
<p><strong>至此，MySQL卸载完成！</strong></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://special711.cn/">星猫博客</a>! This is your very first post. Check <a href="https://special711.cn/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://special711.cn/">troubleshooting</a> or you can ask me on <a href="https://github.com/">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> youfile</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://special711.cn/">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep -v <span class="string">&#x27;^#&#x27;</span> _config.yml</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://special711.cn/">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> _config.yml</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://special711.cn/">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> _config.yml</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://special711.cn/">Deployment</a></p>
]]></content>
      <tags>
        <tag>世界</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统</title>
    <url>/linux%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>linux 的用户切换</p>
<p>​	su - 用户名 ，</p>
<p>​		su - user</p>
<p>​		su - 或 su - root ，可切换到 root用户 </p>
<p>linux 的帮助信息</p>
<p>​	xxx – help 命令  （会展示 xxx 命令的基本用法）</p>
<p>​	man xxx命令（展示 xxx 命令、函数 的操作手册）</p>
<p>​	info xxx命令 （展示更详细的文档）</p>
<p>linux 关机命令</p>
<p>​	sync ，将数据同步到硬盘中</p>
<p>​	shutdown ， 关机</p>
<p>​		shutdown -h ，可以设置关机时间</p>
<p>​			shutdwon - h now ， 立刻关机</p>
<p>​			shutdwon - h 20:11 ， 20:11 关机</p>
<p>​	reboot ， 重启</p>
<p>linux 文件权限</p>
<p>​	用户和用户组</p>
<p>​	ls -al 可显示文件或文件夹的详细信息和权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x.   2      root    root     6        6月 9 2021       crash</span><br><span class="line">权限         链接数   拥有者   用户组   文件容量     修改日期时间   文件或文件夹名</span><br></pre></td></tr></table></figure>

<p>r ， 可读</p>
<p>w ，可写</p>
<p>X ，可执行</p>
<p>权限开头的 - ，表示这是一个文件，</p>
<p>​		    d ，表示这是一个文件夹</p>
<p>权限里面的 - 表示无权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d      rwx           r-x          	r-x</span><br><span class="line">文件   拥有者权限     用户组权限     其他用户权限</span><br></pre></td></tr></table></figure>

<p>权限可用数字表示，rwx 可看做三位二进制数 ，1 1 1，写成十进制就是7 ，- 表示二进制数 0 </p>
<p>rwxr-xr-x ， 写位数字就是 7 5 5</p>
<p>注：加入用户组的成员，只需要 r 权限就可以读到文件，其他用户需要 r 和 x 权限才可读到文件。</p>
<p>如 ： -rw-r–r–  root root a.txt ，这个文件 这有root用户，和root用户组的人可以看到，其他用户看不到</p>
<p>修改为 -rw-r–r-x ， 其他用户才可读到</p>
<p>文件权限修改</p>
<p>chgrp ， 修改文件或目录所属用户组</p>
<p>chown ， 修改文件或目录拥有者</p>
<p>chmod ，修改文件或目录权限</p>
<p>1、chgrp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp [-R] groupname a/b ，写上 -R ，表示将a/b下所有子目录及其文件用户组权限改为 groupname </span><br></pre></td></tr></table></figure>

<p>2、chown</p>
<p>​	chown 用法与chgrp类似</p>
<p>​	chown 还可同时修改文件拥有者和用户组的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown [-R] username:groupname a/b </span><br></pre></td></tr></table></figure>

<p>3、chmod</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod [-R] 权限 a/b</span><br><span class="line">chmod [-R] drwxrwxrwx a/b 或 chmod [-R] 777 a/b</span><br></pre></td></tr></table></figure>



<p>符号修改权限</p>
<p>用户：u(user)、g(group)、o(other)、a(all)</p>
<p>权限的修改：+、-、&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+w a.txt ， 给所有用户加上可写的权限</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a-x a.txt ， 将所有用户的执行权限去掉</span><br></pre></td></tr></table></figure>



<p>目录的操作</p>
<p>cd  ，切换目录</p>
<p>pwd  ， 显示当前目录</p>
<p>mkdir ， 新建目录</p>
<p>rmdir ， 删除目录</p>
<p>1、pwd </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd [-P] ，可显示真实目录，而非链接目录</span><br></pre></td></tr></table></figure>



<p>2、mkdir，只能建立不存在的目录，存在则报错</p>
<p>mkdir ， 新建目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></table></figure>

<p>mkdir -m ，新建目录时添加权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -m 777 test</span><br></pre></td></tr></table></figure>

<p>mkdir -p ，新建目录时，顺便建立上级目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p test1/test2/test</span><br></pre></td></tr></table></figure>

<p>mkdir -mp ，新建目录时添加权限，顺便建立上级目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -mp 777 test1/test2/test	</span><br></pre></td></tr></table></figure>



<p>3、rmdir ， 只能删除存在的空目录，不存在则报错，目录不为空报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir a/b</span><br><span class="line">rmdir -P a/b/c ， 删除所有空目录</span><br></pre></td></tr></table></figure>

<p>要删除有文件的目录，需要使用 rm -r </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -r a</span><br><span class="line">删除a目录及目录下的文件</span><br></pre></td></tr></table></figure>



<p>文件和目录管理</p>
<p>ls， 查看文件和目录</p>
<p>cp ，复制 文件或目录, 重命名文件</p>
<p>rm ， 删除文件或目录</p>
<p>mv ， 移动文件或目录或重命名</p>
<p>1、ls</p>
<p>​	ls ,  查看所有文件和目录，不包括隐藏文件</p>
<p>​	ls -a , 查看全部文件和目录，及其隐藏文件，隐藏文件用 .文件名表示</p>
<p>​	ls -l , 可写为 ll ,列出文件和目录的详细信息</p>
<p>​	ls -al , 列出全部文件和目录及其隐藏文件的详细信息</p>
<p>2、cp ， 复制 文件或目录, 重命名文件</p>
<p>​	cp</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /var/log/a.log  /var/log/b.log , 将a.log文件复制到/var/log目录下，并重命名为b.log</span><br></pre></td></tr></table></figure>

<p>​	cp -p , 复制文件，并复制属性和原本的权限</p>
<p>​	cp -i ，若目标文件存在，也在复制前会询问</p>
<p>​	cp -s ， 软连接，复制成符号链接文件，快捷方式</p>
<p>​	cp -l ， 硬连接，源文件和目标文件将共享相同的 inode（索引节点），它们被视为同一个文件的不同引用。</p>
<p>硬链接和软连接也可使用 ln 命令创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -s 源文件  目标文件 </span><br><span class="line">cp -s /var/log/a.log  /var/log/b.log</span><br><span class="line">ll </span><br><span class="line">lrwxrwxrwx. 1 root   root   5   3月  31 22:05 /var/log/b.log -&gt; /var/log/a.log，快捷方式-&gt;源文件</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>硬连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -l 源文件  目标文件</span><br><span class="line">ln -l /var/a.txt  /var/b.txt</span><br></pre></td></tr></table></figure>

<p>软连接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s 源文件  目标文件</span><br><span class="line">ln -s /var/a.txt  /var/b.txt</span><br></pre></td></tr></table></figure>

<p>注：硬链接是指向文件系统中同一数据块的新文件名，它们实际上指向同一个inode（文件的索引节点）。这意味着硬链接与原始文件在内容上完全相同，删除其中一个硬链接并不会影响其他硬链接或原始文件。只有当所有硬链接和原始文件都被删除后，数据块才会被释放。硬链接的一个主要限制是它们不能跨文件系统，并且只能为文件创建，而不能为目录创建。此外，硬链接的文件权限一定和源文件一样。</p>
<p>​	软连接（也称为符号链接）是在文件系统中创建一个特殊文件，其中包含指向另一个文件的路径，类似于Windows系统中的快捷方式。软连接与原始文件不在同一inode，因此它们是两个不同的文件。软连接只是一个指向原始文件路径的文本链接，删除原始文件后，软连接仍然存在，但指向的路径将失效。软连接的一个主要优点是它可以跨文件系统，并且可以为文件和目录（允许不存在）创建链接。此外，软连接的文件权限可以和源文件不一样。可以使用软连接缩短路径地址。</p>
<p>​	硬链接和软连接各有其特点和适用场景。硬链接主要用于文件备份、多人共享文件。软连接主要用于缩短路径，文件或目录的重定向。</p>
<p>3、rm ， 删除文件或目录</p>
<p>​	rm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm a.txt ，存在则删除，不存在则报错</span><br><span class="line">rm /a/b ， 目录为空则删除，不为空则报错</span><br></pre></td></tr></table></figure>

<p>​	rm -i ， 删除文件或目录，删除时询问</p>
<p>​	rm -f ， 强制删除文件，忽略不存在的文件，不警告</p>
<p>​	rm -r ， 删除目录及其下所有文件和子目录，不存在则报错，删除时询问</p>
<p>4、mv ， 移动文件或目录，或重命名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv a/b.txt  c/d.txt ， 将 a/b.txt文件移动到 c 目录下，并重命名为 d.txt</span><br><span class="line">mv a b , 将 a 目录重命名为 b目录</span><br></pre></td></tr></table></figure>

<p>​	mv -f ， 不管目标文件是否存在，都直接覆盖。</p>
<p>​	mv -i ， 若目标文件存在，则询问</p>
<p>​	</p>
<p>文件内容查看</p>
<p>cat ，从第一行开始显示所有内容</p>
<p>tac ， 从最后一行显示所有内容</p>
<p>nl ， 展示所以内容，并显示行号</p>
<p>more ， 根据需要显示内容，一页一页显示</p>
<p>less ， 与more类似，但可向前翻页</p>
<p>head ， 只显示前几行</p>
<p>tail ， 只显示后几行</p>
<p>1、cat ， 从第一行开始显示所有内容</p>
<p>​	cat -b ， 显示行号</p>
<p>2、head ，  只显示前几行，默认显示前10行</p>
<p>​	head -n 行号  文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">显示前100行的内容</span><br><span class="line">head -n 100 a.txt</span><br><span class="line">只打印前100行的内容</span><br><span class="line">head -n -100 a.txt</span><br></pre></td></tr></table></figure>

<p>3、tail ， 只显示后几行，默认显示后10行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">显示后100行的内容</span><br><span class="line">tail -n 100 a.txt</span><br><span class="line">只打印后100行的内容</span><br><span class="line">tail -n -100 a.txt</span><br></pre></td></tr></table></figure>

<p>若要取第11行到20行 的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先取前20行，再取后10行</span><br><span class="line">head -n 20 a.txt | tail -n 10 </span><br></pre></td></tr></table></figure>



<p>新建文件</p>
<p>touch  file_name</p>
<p>创建一个空文件，若目标文件存在，也不警告</p>
<p>文件查找</p>
<p>whereis ，查询速度快，但是只能查指定的几个目录，可用 whereis -l 查看有哪些目录可以查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whrer 文件名</span><br></pre></td></tr></table></figure>

<p>locate ， 查询速度快，但只能查已存在数据库的文件，数据库默认一天更新一次，所以需要手动更新，updatedb命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate 文件名</span><br></pre></td></tr></table></figure>

<p>find </p>
<p>​	find [目录]  -name 文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find -name http.txt</span><br><span class="line">find /var -name a.txt</span><br></pre></td></tr></table></figure>

<p>​	find 还可以用通配符查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find -name *tt*p.txt</span><br><span class="line">find /var -name scrip*.txt</span><br></pre></td></tr></table></figure>



<p>文件内容查找</p>
<p>grep </p>
<p>​	grep xxx  文件 ， 在指定文件中查找 xxx ，显示 a 所在行的一整行内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -n &#x27;a&#x27; /b.txt	</span><br></pre></td></tr></table></figure>

<p>​	grep ^xxx  文件  ， 在指定文件中查找以 xxx 开头的行，并标明行号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -n &#x27;^a&#x27; /b.txt</span><br></pre></td></tr></table></figure>

<p>​	grep *xxx  文件 ， 在指定文件中查找以 xxx 结尾 的关键字</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;*a&#x27; /b.txt</span><br></pre></td></tr></table></figure>

<p>​	grep -i  xxx  文件，忽略大小写查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -i &#x27;a&#x27; /b.txt</span><br></pre></td></tr></table></figure>

<p>​	grep -r xxx 目录 ， 递归查找包含 xxx 的文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -r &#x27;a&#x27; /var </span><br></pre></td></tr></table></figure>



<p>删除指定的行</p>
<p>1、删除指定包含 某个字符串的行。</p>
<p>可以使用 grep -v 反向匹配其他不需要删除的行，将这些行放到新文件，再将新文件复制到原文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -v &#x27;关键字&#x27; a.txt &gt; aNew.txt &amp;&amp; mv aNew.txt a.txt</span><br></pre></td></tr></table></figure>



<p>2、删除具体的某一行，给出行号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;&lt;行号&gt;d&#x27; &lt;文件名&gt;</span><br></pre></td></tr></table></figure>

<p>如要删除 a.txt 文件中的第 5 行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;5d&#x27; a.txt</span><br></pre></td></tr></table></figure>



<p>文件的打包压缩与解压</p>
<p>​	常见的压缩工具为gzip、bzip2、xz，但是这些工具只能压缩单个文件，利用 tar 命令可以将多个文件或目录打包成一个文件或目录，也可以对这些打包后的文件目录压缩，tar 还可以解压缩。</p>
<p>​	bzip、xz 是比 gzip 压缩比更高的工具，但是压缩时间也变长。与gzip 用法类似。</p>
<p>gzip</p>
<p>​	gzip 文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip a.txt</span><br></pre></td></tr></table></figure>

<p>​	gip 会将源文件压缩为 带有 .gz 后缀的文件。同时源文件会被删除。</p>
<p>​	如果源文件为纯文本文件，则可使用 zcat &#x2F; zmore &#x2F; zless &#x2F; zgrep 读取，用法与 cat &#x2F; more &#x2F; less &#x2F; grep 类似。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解压文件</span><br><span class="line">gzip -d 文件，会将压缩文件解压成源文件，同时删除压缩文件。</span><br><span class="line">gzip -d a.txt.gz</span><br><span class="line">不解压，直接显示解压后的源文件内容</span><br><span class="line">zcat a.txt.gz </span><br><span class="line">不解压，在压缩文件中查找关键字</span><br><span class="line">zgrep &#x27;block&#x27; a.txt.gz</span><br></pre></td></tr></table></figure>



<p>使用tar 打包压缩</p>
<p>由于tar 命令 的选项太过，简单写几个</p>
<p>压缩</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zcvf 压缩后的文件名 源文件， -z 表示压缩为 .gz格式，表示将源文件打包成.gz格式，并查看被打包的文件名。</span><br><span class="line">tar -zcvf b.txt.tar.gz b.txt</span><br></pre></td></tr></table></figure>

<p>如果只是打包，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf 打包后的文件名 源文件</span><br><span class="line">tar -cvf  b.txt.tar  b.txt</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf 压缩文件 -C 解压后存放的目录 ,-x 表示解压缩 ，-C 表示对特定目录解压缩。</span><br><span class="line">tar -zxvf b.txt.tar.gz /var</span><br></pre></td></tr></table></figure>



<p>vim 编辑器</p>
<p>vim 与 vi 基本用法相同，分为三种模式，一般命令模式、编辑模式、命令行模式</p>
<p>一般命令模式</p>
<p>​	可移动光标，复制、粘贴文本内容</p>
<p>​	在一般命令模式，按下[ctrl]+[f] 可 向下翻页，[ctrl]+[b] 向上翻页。</p>
<p>编辑模式</p>
<p>​	在一般命令模式中，按下 i  会进入编辑模式，可以修改删除文本内容。</p>
<p>​	在编辑模式中，修改后先按下【ESC】键，退出编辑模式，然后按下 [ : q ] 不保存退出 vim编辑器</p>
<p>​	按下 [ : wq ] 保存退出 vim编辑器</p>
<p>​	按下 [ : wq! ] 可在无权限时强制保存退出 vim编辑器</p>
<p>命令行模式</p>
<p>​	在一般命令模式中按下[ &#x2F; ] 直接将光标移动到最下面一行，这个模式可进行显示行号、查找数据等操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/aa ， 查找文件内容中的 aa</span><br></pre></td></tr></table></figure>



<p>Shell</p>
<p>换行</p>
<p>​	使用 [ &#x2F; ] 转义 回车键。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# vim /var/lo\</span><br><span class="line">&gt; g/boot.log</span><br></pre></td></tr></table></figure>

<p>变量</p>
<p>echo</p>
<p>设置变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=abc</span><br></pre></td></tr></table></figure>

<p>读取变量，变量未设置时，读取内容为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $变量名 或者  echo $&#123;变量名&#125;</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure>



<p>变量的设置规则</p>
<p>1、等号两边不能有空格，变量内容有空格，可使用 单引号[‘ ‘] 或 双引号 [“ “] 连起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# a=&#x27;a b&#x27;</span><br><span class="line">[root@localhost /]# echo $a </span><br><span class="line">a b</span><br></pre></td></tr></table></figure>

<p>2、变量名称只能是英文或数字，数字不能作为开头字符。</p>
<p>3、单引号内如有特殊符号（[Enter]、$、\、空格、’ 等），可使用 [ \ ]转义。单引号内的 <code>$(command)</code> 或反引号 <code>command</code> 不会被执行。在单引号内的内容被视为字面字符串，即 Bash 不会尝试解释其中的变量或命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# a=&#x27;a\ b&#x27;</span><br><span class="line">[root@localhost /]# echo $a </span><br><span class="line">-&gt;a b</span><br><span class="line"></span><br><span class="line">name=he</span><br><span class="line">echo &#x27;its my $name&#x27;</span><br><span class="line">-&gt;its my $name</span><br></pre></td></tr></table></figure>

<p>4、变量引用，双引号 [ “ “ ]，在双引号内，Bash 会解释变量，并用变量的值替换它。双引号内的 <code>$(command)</code> 或 <code>command</code> 会被执行，并替换为命令的输出。大多数特殊字符在双引号内仍具有特殊含义，但 $, &#96;&#96;, 和 \ 有特殊行为。其中，$ 用于变量替换，&#96; 用于命令替换，而 \ 用于转义下一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=abc</span><br><span class="line">myname=&quot;its $name&quot;</span><br><span class="line">echo myname</span><br><span class="line">-&gt;its abc</span><br><span class="line"></span><br><span class="line">now=$(date)</span><br><span class="line">echo &quot;today is $now&quot;</span><br><span class="line">-&gt;today is 年月日时间</span><br></pre></td></tr></table></figure>





<p>5、环境变量的设置</p>
<p>export  变量名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将 name 变量 在其他子程序中执行，需要设置环境变量，其他进程才会获取到值。</span><br><span class="line">[root@localhost /]# name=***</span><br><span class="line">[root@localhost /]# bash 开启子进程</span><br><span class="line">[root@localhost /]# echo $name</span><br><span class="line">[root@localhost /]# 获取不到</span><br><span class="line">[root@localhost /]# exit 退出子进程</span><br><span class="line">[root@localhost /]# export name 设置环境变量</span><br><span class="line">[root@localhost /]# bash 重新开启子进程</span><br><span class="line">[root@localhost /]# echo $name</span><br><span class="line">[root@localhost /]# ***</span><br></pre></td></tr></table></figure>



<p>取消变量</p>
<p>unset 变量名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset name</span><br></pre></td></tr></table></figure>



<p>变量键盘读取</p>
<p>read</p>
<p>read [ -p description ]  [ -t 时间] 变量名 ， -p 是提示信息， -t 是限制时间，单位秒</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需求： please input name:   在30秒内</span><br><span class="line">[root@localhost /]# read -p &quot;please input name:&quot; -t 30 name</span><br><span class="line">[root@localhost /]# please input name:aa</span><br><span class="line">[root@localhost /]# echo $name</span><br><span class="line">[root@localhost /]# aa</span><br></pre></td></tr></table></figure>

<p>将字符串写入文件</p>
<pre><code>覆盖文件中内容
echo 字符串&gt;文件名 

不覆盖文件中内容。
echo 字符串&gt;&gt;文件名 
</code></pre>
<p>正则表达式</p>
<p>查找特定字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -n &#x27;the&#x27; regularex.txt  在regularex.txt文件中查找有 the 的行，并显示行号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -in &#x27;the&#x27; regularex.txt  在regularex.txt文件中查找有 the 的行，忽略大小写，并显示行号</span><br></pre></td></tr></table></figure>

<p>查找相似字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件中有test 、 taste 两个关键字，需要包含这两个关键字的行都找出来。</span><br><span class="line">grep -n &#x27;t[ea]st&#x27; regularex.txt</span><br></pre></td></tr></table></figure>

<p>反向查找字符串 [^]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找&#x27;oo&#x27;前不带&#x27;g&#x27;的字符串的行，显示行号</span><br><span class="line">grep -n &#x27;[^g]oo&#x27; regularex.txt</span><br><span class="line">查找&#x27;oo&#x27;前不带&#x27;a-z&#x27;小写字母的行，显示行号</span><br><span class="line">grep -n &#x27;[^a-z]oo&#x27; regularex.txt</span><br></pre></td></tr></table></figure>

<p>行首和行尾 </p>
<p>行首 ^</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找 以 the 开头的行</span><br><span class="line">grep -n &#x27;^the&#x27; regularex.txt</span><br><span class="line">查找 以a-z小写字母开头的行</span><br><span class="line">grep -n &#x27;^[a-z]&#x27; regularex.txt</span><br><span class="line">查找 以英文字母开头的行</span><br><span class="line">grep -n &#x27;^[a-zA-Z]&#x27; regularex.txt</span><br><span class="line">查找 不以英文字母开头的行</span><br><span class="line">grep -n &#x27;^[^[a-zA-Z]&#x27; regularex.txt</span><br></pre></td></tr></table></figure>

<p>行尾 $</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找以 o 结尾的行</span><br><span class="line">grep -n &#x27;o$&#x27; regularex.txt</span><br><span class="line">查找以 . 结尾的行</span><br><span class="line">grep -n &#x27;\.$&#x27; regularex.txt   ， .需要 \ 转义</span><br></pre></td></tr></table></figure>

<p>查找空白行  ^$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -n &#x27;^$&#x27; regularex.txt </span><br></pre></td></tr></table></figure>

<p>-v 也可以反向匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找非空白行和非 # 开头的行</span><br><span class="line">grep -v &#x27;^$&#x27; regularex.txt | grep -vn &#x27;^#&#x27;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep -vn &#x27;^$&#x27; regularex.txt | grep -v &#x27;^#&#x27; 是错的，</span><br><span class="line">行号必须在最后一次的过滤再加，因为在开始加的话，后面的查询语句会将行号作为开头字符。</span><br></pre></td></tr></table></figure>

<p>任意一个字符 .   与重复字符 *</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找 g??d ，以g开头，d结尾的四个字符的字符串所在行</span><br><span class="line">grep &#x27;g..d&#x27; regularex.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找 包含 o 的行</span><br><span class="line">grep &#x27;o*&#x27; regularex.txt ，会查出来至少包含0个o的行</span><br><span class="line">查找 至少包含一个 o 的行</span><br><span class="line">grep &#x27;oo*&#x27; regularex.txt</span><br><span class="line">查找 两个 g 之间所有包含 o 的行</span><br><span class="line">grep &#x27;goo*g&#x27; regularex.txt</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找包含g开头，g结尾的字符串的行</span><br><span class="line">grep &#x27;g.*g&#x27; regularex.txt</span><br></pre></td></tr></table></figure>



<p>wc 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc 命令</span><br><span class="line">wc -l  统计行数</span><br><span class="line">   -m  统计字符数</span><br></pre></td></tr></table></figure>

<p>统计行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -l &lt; a.txt   统计文本的行数  ，输出9</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -m &lt; a.txt   统计文本的字符数 ，输出 142</span><br></pre></td></tr></table></figure>

<p>不加 &lt;  就会输出文件名， 如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -l a.txt   ,输出9 a.txt</span><br></pre></td></tr></table></figure>





<p>sed命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [options] &#x27;command&#x27; file(s) </span><br><span class="line"></span><br><span class="line">sed [options] -f scriptfile file(s)  这个命令是读取指定脚本文件scriptfile中的命令，用于指定的某个文件</span><br></pre></td></tr></table></figure>

<p>[options] 中的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e : 可以处理多个命令处理输入的文本文件；</span><br><span class="line">-f &lt;script文件&gt;或--file=&lt;script文件&gt;：以选项中指定的script脚本文件来处理输入的文本文件；</span><br><span class="line">-h或--help：显示帮助；</span><br><span class="line">-n或--quiet或——silent：仅显示script处理后的结果；</span><br><span class="line">-V或--version：显示版本信息。</span><br><span class="line">-i：编辑文件</span><br></pre></td></tr></table></figure>

<p>command 参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d 删除，删除选择的行。</span><br><span class="line">D 删除模板块的第一行。</span><br><span class="line">s 替换指定字符。</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;对于 sed  的所有命令，不加 -i ，就是输出修改后的文本内容，但不会保存到原文件&#x3D;&#x3D;</p>
<p>文本替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/../..&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &#x27;s/book/books&#x27; a.txt</span><br><span class="line">将a.txt 中的所有book 替换为books ，只是输出修改后的内容，但不会保存到原文件。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;s/book/books&#x27; a.txt</span><br><span class="line">将a.txt 中的所有book 替换为books ,并将修改保存到原文件。</span><br></pre></td></tr></table></figure>

<p>删除行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &#x27;/^$/d&#x27; a.txt</span><br><span class="line">删除 a.txt中的空白行</span><br><span class="line"></span><br><span class="line">sed &#x27;2d&#x27; a.txt  </span><br><span class="line">删除 a.txt中的第二行</span><br><span class="line"></span><br><span class="line">sed &#x27;2,$d&#x27; a.txt</span><br><span class="line">删除文件的第2行到末尾所有行</span><br><span class="line"></span><br><span class="line">sed &#x27;$d&#x27; file</span><br><span class="line">删除文件最后一行</span><br><span class="line"></span><br><span class="line">sed &#x27;/^test/&#x27;d file</span><br><span class="line">删除文件中所有开头是test的行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;2d&#x27; a.txt</span><br><span class="line">删除a.txt中的第二行，并保存到原文件。</span><br></pre></td></tr></table></figure>



<p>执行多条命令，执行结果与顺序有关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -e</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -e &#x27;1,5d&#x27; -e &#x27;s/test/check/&#x27; file</span><br><span class="line">删除file中的1-5行，然后再将test改为check</span><br></pre></td></tr></table></figure>



<p>awk 命令</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s、gitlab、gitlab-runner自动化部署</title>
    <url>/k8s%E3%80%81gitlab%E3%80%81gitlab-runner%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>1、kubernetes 、组件安装及集群搭建教程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://gitee.com/yooome/golang/blob/main/21-k8s%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B/Kubernetes%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B.md#10-dashboard</span><br></pre></td></tr></table></figure>


<p>Dashboard 页面需要在firefox浏览器打开，如果要在chrome\edge浏览器打开，需要安装SSL 证书</p>
<p>访问路径 <a href="https://192.168.223.129:30009/">https://192.168.223.129:30009</a></p>
<p>3、gitlab安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[GitLab部署.md]: E:\***.md</span><br></pre></td></tr></table></figure>

<p>访问路径 <a href="http://192.168.223.129:30080/">http://192.168.223.129:30080</a></p>
<p>gitlab 部署完，需要设置ssh,可免密拉取代码。</p>
<p>由于在 Docker 容器中，<code>gitlab-ctl</code> 并不直接暴露给宿主机，因为它在容器的内部环境中。所以需要使用 命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器名或ID gitlab-ctl ***</span><br></pre></td></tr></table></figure>



<p>4、gitlab-runner 安装</p>
<p>vi docker-compose.yml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3&#x27;</span><br><span class="line">service:  </span><br><span class="line">  gitlab-runner:</span><br><span class="line">    image: &#x27;gitlab/gitlab-runner:latest&#x27;</span><br><span class="line">    privileged: true</span><br><span class="line">    container_name: gitlab-runner</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x27;/opt/store/gitlab-runner:/etc/gitlab-runner&#x27;</span><br><span class="line">      - &#x27;/var/run/docker.sock:/var/run/docker.sock&#x27; </span><br><span class="line">    networks:</span><br><span class="line">      - gitlab-runner_default</span><br><span class="line">    restart: always</span><br><span class="line">    </span><br><span class="line">networks:</span><br><span class="line">  gitlab-runner_default:</span><br></pre></td></tr></table></figure>

<p>安装java8</p>
<p><a href="https://www.oracle.com/java/technologies/downloads/#java8">https://www.oracle.com/java/technologies/downloads/#java8</a></p>
<p>选择 linux x64 tar.gz版本</p>
<p>解压 包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /opt/environment</span><br><span class="line">tar -zxvf jdk-8u411-linux-x64.tar.gz -C /opt/environment</span><br></pre></td></tr></table></figure>

<p>添加到环境变量</p>
<p>vi &#x2F;etc&#x2F;profile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set java environment</span><br><span class="line">JAVA_HOME=/opt/environment/jdk-1.8</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export JAVA_HOME PATH</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile  生效</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>

<p>安装 maven</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -LO https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz</span><br></pre></td></tr></table></figure>

<p>解压</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.8.8-bin.tar.gz -C /opt/environment</span><br></pre></td></tr></table></figure>

<p>添加环境变量</p>
<p>vi &#x2F;etc&#x2F;profile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Set maven environment</span><br><span class="line">MAVEN_HOME=/opt/environment/apache-maven-3.8.8</span><br><span class="line">PATH=$PATH:$MAVEN_HOME/bin</span><br><span class="line">export MAVEN_HOME PATH</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /etc/profile  生效</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>



<p>注册 gitlab -runner</p>
<p>1、获取token</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240519092836328.png" alt="image-20240519092836328"></p>
<p>注册</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitlab-runner register</span><br><span class="line">因为 gitlab-runner 是通过docker 安装的，所以只能在gitlab-runner容器内运行这个命令</span><br><span class="line"></span><br><span class="line">docker exec -it 容器ID gitlab-runner register</span><br></pre></td></tr></table></figure>

<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/image-20240519093114352.png" alt="image-20240519093114352"></p>
<p>详细过程</p>
<p><a href="https://blog.csdn.net/m0_51510236/article/details/134874324">https://blog.csdn.net/m0_51510236/article/details/134874324</a></p>
<p>vi dockerfile</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8-jdk-slim </span><br><span class="line">COPY ./k8s-test-0.0.1-SNAPSHOT.jar /tmp/app/app.jar</span><br><span class="line">EXPOSE 8090</span><br><span class="line"></span><br><span class="line"># 运行程序</span><br><span class="line">ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/tmp/app.jar&quot;]</span><br></pre></td></tr></table></figure>

<p>构建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t k8s-test:1.0 .  后面的 . 代表Dockerfile 所在的目录为当前目录</span><br></pre></td></tr></table></figure>

<p>远程推送镜像</p>
<p>1、阿里云镜像仓库</p>
<p>具体参考</p>
<p><a href="https://cr.console.aliyun.com/repository/cn-hangzhou/k8s-images01/k8s-test/details">https://cr.console.aliyun.com/repository/cn-hangzhou/k8s-images01/k8s-test/details</a></p>
<p>2、私有化镜像仓库部署</p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统的安装文档</title>
    <url>/linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%89%E8%A3%85%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>安装虚拟机，vmware</p>
<h3 id="Debian-安装"><a href="#Debian-安装" class="headerlink" title="Debian 安装"></a>Debian 安装</h3><p>下载debian iso镜像</p>
<p>进入 debian官网 <a href="https://www.debian.org/">https://www.debian.org/</a></p>
<p>点击其他下载链接</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291605808.png">



<p>点击获取完整镜</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291605303.png" alt="image-20240329160514227" style="zoom:67%;">

<p>通过 HTTP 下载 CD&#x2F;DVD 映像文件</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291606033.png" alt="image-20240329160619964" style="zoom:67%;">

<p>选择DVD，amd64</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291607100.png" alt="image-20240329160702026"></p>
<p>点击下载镜像</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291607560.png" alt="image-20240329160733488" style="zoom:67%;">

<p>进入vmware安装镜像</p>
<p>第一步选择安装图像化界面 ，graphic install</p>
<p>网络配置选择暂不配置</p>
<p>磁盘分区，选择最大连续空间</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291628305.png" alt="image-20240329162800220" style="zoom:67%;">

<p>boot (启动)200M， swap (交换区) (虚拟机配置的内存大小，如配置了2G，这里写2G)&#x2F;  ，&#x2F; (根目录，数据存放，依据虚拟机配置的空间)</p>
<p>也可以设置将所有文件放入同一个分区</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291617845.png" alt="image-20240329161729770" style="zoom:67%;">

<p>是否使用网络镜像点，选择否，系统自带默认镜像源为阿里云镜像源</p>
<p>软件选择，桌面选KDE或GNOME</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291618689.png" alt="image-20240329161852601" style="zoom:67%;">

<p>是否添加GRUB启动，选择是</p>
<p>重启</p>
<h3 id="U盘做启动盘安装CentOS7"><a href="#U盘做启动盘安装CentOS7" class="headerlink" title="U盘做启动盘安装CentOS7"></a>U盘做启动盘安装CentOS7</h3><p>镜像下载完毕后，插入U盘，用软碟通打开</p>
<p><a href="https://post.smzdm.com/p/akk9mwe4/pic_4/"><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403310053754.png" alt="CentOS 安装全过程，手把手教你打造企业级服务器！"></a></p>
<p>确认U盘后，选择写入，制作完毕后开始安装。</p>
<h2 id><a href="#" class="headerlink" title></a></h2><p>插入U盘，进入BIOS设置，将启动顺序设置为USB启动。</p>
<p>选择Install Centos 7 安装</p>
<p><a href="https://post.smzdm.com/p/akk9mwe4/pic_6/"><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403310053298.png" alt="CentOS 安装全过程，手把手教你打造企业级服务器！"></a></p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统的网络配置文档</title>
    <url>/linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>进入虚拟网络编辑器</p>
<p>选择vmnet8模式，设置子网ip  子网掩码</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202404051631873.png" style="zoom:67%;">



<p>DHCP设置 ，</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291541604.png" alt="image-20240329154114539" style="zoom:67%;">

<p>NAT设置</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202404051631742.png" style="zoom:67%;">



<p>网络共享中心  &gt;  更改适配器设置  &gt; 选择vmnet8，点击属性，选择ipv4，点击属性</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202404051629178.png" style="zoom:67%;">

<p>ip与NAT设置中网关IP一致</p>
<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202404051627606.png" alt="image-202403291545658" style="zoom:67%;">



<p>查看网卡名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip addr</span><br></pre></td></tr></table></figure>

<img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202404051632488.png" style="zoom:67%;">

<p>显示为 ens33</p>
<h3 id="centos7网络配置"><a href="#centos7网络配置" class="headerlink" title="centos7网络配置"></a>centos7网络配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在root用户下： su </span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line"></span><br><span class="line">TYPE=&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD=&quot;none&quot;</span><br><span class="line">BROWSER_ONLY=&quot;no&quot;</span><br><span class="line">DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6INIT=&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF=&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE=&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL=&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;</span><br><span class="line">NAME=&quot;ens33&quot;</span><br><span class="line">UUID=&quot;febd5220-8d5d-30a8-a668-fcdd922512e0&quot;</span><br><span class="line">DEVICE=&quot;ens33&quot;</span><br><span class="line"></span><br><span class="line">//需要修改的地方</span><br><span class="line">ONBOOT=&quot;yes&quot;</span><br><span class="line">BOOTPROTO=&quot;static&quot;</span><br><span class="line"></span><br><span class="line">//需要添加的地方</span><br><span class="line">IPADDR=&quot;192.168.2.128&quot;  </span><br><span class="line">GATEWAY=&quot;192.168.2.1&quot;  </span><br><span class="line">NETMASK=255.255.255.0&quot; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置DNS服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/resolved.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DNS=114.114.114.114</span><br></pre></td></tr></table></figure>

<p>配置完成后，重启网络</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>





<p>注意：如果 ens33 网卡为DOWN，意味着它目前处于禁用状态，可能没有被正确配置或者启动。需要确保ens33接口已启用并配置了IP地址。 </p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202403291756769.png" alt="image-20240329175622648"></p>
<p>可以通过以下命令启用ens33接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo ip link set ens33 up</span><br><span class="line">sudo ip addr add &lt;ip_address&gt;/&lt;subnet_mask&gt; dev ens33</span><br><span class="line">	如：sudo ip addr add 192.168.2.128/24 dev ens33</span><br></pre></td></tr></table></figure>



<h3 id="Debian12系统网络配置"><a href="#Debian12系统网络配置" class="headerlink" title="Debian12系统网络配置"></a>Debian12系统网络配置</h3><p>编辑网络配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/network/interfaces</span><br></pre></td></tr></table></figure>

<p>默认</p>
<p><img src="https://picgo-1311649419.cos.ap-guangzhou.myqcloud.com/picgo/202404051632405.png"></p>
<p>在后面添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auto ens33</span><br><span class="line">iface ens33 inet static</span><br><span class="line">address 192.168.2.128</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.2.1</span><br></pre></td></tr></table></figure>

<p>保存退出，重启网络</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart networking</span><br></pre></td></tr></table></figure>

<p>设置dns</p>
<p>debian 12安装后默认没有&#x2F;etc&#x2F;resolv.conf 文件，需要先创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/resolv.conf</span><br></pre></td></tr></table></figure>

<p>添加内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.8.4</span><br></pre></td></tr></table></figure>

<p>保存退出，重启网络</p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>儿童节</title>
    <url>/%E5%84%BF%E7%AB%A5%E8%8A%82/</url>
    <content><![CDATA[<style>  
@keyframes bounce {  
  0%, 100% { transform: translateY(0); }  
  50% { transform: translateY(-20px); }  
}  
.bouncing-text {  
  display: inline-block;  
  animation: bounce 2s infinite;  
}  
</style>  

<p>今天是<span class="bouncing-text">儿童节</span>！</p>

<p><img src="http://img2.baidu.com/it/u=2468907217,3090369167&fm=253&app=138&f=JPEG?w=1110&h=730" alt="儿童节图片" title="儿童节"></p>
]]></content>
      <categories>
        <category>节日</category>
      </categories>
      <tags>
        <tag>儿童节</tag>
      </tags>
  </entry>
  <entry>
    <title>文章发布脚本改进</title>
    <url>/%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E8%84%9A%E6%9C%AC%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd D:/Develop/workspace/javaworkspace/website/source/temp/</span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;获取文件名&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">cd D:/Develop/workspace/javaworkspace/website/source/temp/</span><br><span class="line">#获取文件名</span><br><span class="line">filename=$(ls *.md)</span><br><span class="line">#去掉后缀</span><br><span class="line">filename_no_ext=&quot;$&#123;filename%.*&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始写入front-matter&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line"></span><br><span class="line">#获取第一行的内容</span><br><span class="line">first_line1=$(sed -n &#x27;1p&#x27; $filename)</span><br><span class="line">#获取第二行的内容</span><br><span class="line">first_line2=$(sed -n &#x27;2p&#x27; $filename)</span><br><span class="line"></span><br><span class="line">#删除第一行、第二行的内容</span><br><span class="line">sed -i &#x27;1,2d&#x27; $filename</span><br><span class="line"></span><br><span class="line">#写入front-matter</span><br><span class="line">sed -i &#x27;1i\\n&#x27; $filename</span><br><span class="line">sed -i &#x27;1i\---&#x27; $filename</span><br><span class="line">sed -i &#x27;1i\categories: 测试&#x27; $filename</span><br><span class="line">sed -i &#x27;1i\tags: 测试&#x27; $filename</span><br><span class="line">sed -i &#x27;1i\date: $&#123;date&#125;&#x27; $filename</span><br><span class="line">sed -i &quot;1i\\title: $&#123;filename_no_ext&#125;&quot; &quot;$filename&quot;</span><br><span class="line">sed -i &#x27;1i\---&#x27; $filename</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">sed -i &quot;4s/测试/$&#123;first_line1&#125;/&quot; $filename</span><br><span class="line">sed -i &quot;5s/测试/$&#123;first_line2&#125;/&quot; $filename</span><br><span class="line"></span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始复制并删除原文件&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line"></span><br><span class="line">cp $(ls *.md) D:/Develop/workspace/javaworkspace/website/source/_posts/ &amp;&amp; rm -f $(ls *.md)</span><br><span class="line"></span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;发布文章&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line"></span><br><span class="line">cd D:/Develop/workspace/javaworkspace/website</span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo g&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line">npx hexo g</span><br><span class="line">echo -e &quot;\033[47;30m&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;hexo d&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\033[0m&quot;</span><br><span class="line">npx hexo d</span><br><span class="line">sleep 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>网页端出现的问题</title>
    <url>/%E7%BD%91%E9%A1%B5%E7%AB%AF%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>markdown 文件名不能有 + % 等</p>
</blockquote>
<blockquote>
<p>如果出现tags、categories等页面无内容，请检查_config.yml文件，将tags、categories等配置项的path修改为正确的路径。</p>
<blockquote>
<p>或者 在配置中添加 layout: tags layout: categories</p>
</blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: tags</span><br><span class="line">date: $&#123;date&#125;</span><br><span class="line">type: tags</span><br><span class="line">layout: &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>我的书籍，图片大小最好 400X300</p>
<p>如果需要页面只显示文章标题和一部分内容，需要配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">excerpt: &quot;网页端出现的问题，和一部分内容&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
</search>
